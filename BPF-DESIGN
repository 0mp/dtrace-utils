BPF MAPS
--------
Local variable storage
	array map (indexed by variable id)

Global and dynamic variable storage
	hash map (indexed by variable name)

Session state
	array map (indexed by state parameter id)

Probe meta data
	array map (indexed by probe id)

Context map
	array map (indexed by CPU id)

PROBE NAME HASHING
------------------
Legacy DTrace currently reports:
	   13 distinct providers
	   84 distinct modules
	42405 distinct functions
	  742 distinct probe names
	88928 distinct probes

Hash by module name, function name, probe name, and mod:func:name.  When doing
a string constant lookup of any element, use the hashtable for that element.
When doing a shell wildcard pattern match, iterate over all hash buckets by
iterating over the hash slots, and for each non-empty hash slot, iterate over
the buckets linked to that slot, applying the wildcard pattern to the string
value for which the bucket was created.

OPERATIONS
----------
    List probes (-l)
    ----------------
	This argument (mutually exclusive with -A, -G, -h, -V) requests a list
	of probes that match the probe specifications found in the provided
	script or command line actions.

	The probe specifications are given in the following format:

		[ [ [ <gstr> : ] <gstr> : ] <gstr> : ] <gstr>

	where
		<gstr> is either a string constant or a shell wildcard pattern
		       (an empty string is the same as a * pattern)

    Version (-V)
    ------------
	This argument (mutually exclusive with -A, -G, -h, -l) is used to
	display the DTrace API version inforamtion.  When verbose output is
	requested (-v), information about the DTrace application version and
	version control identifiers is included as well.

DTRACE BPF PROGRAM CONVENTIONS
------------------------------
    Reserved registers
    ------------------
	%r9	- pointer to the output scratch buffer

    BPF function implementing a D clause
    ------------------------------------
	The BPF function that implements a specific D clause has the following
	prototype:

		int bpf_action(void *ctx, struct dt_bpf_context *dctx)

	This means that the BPF generated by the DTrace compiler must provide a
	function prologue that saves %r1 (ctx, which is PTR_TO_CTX) and %r2
	(dctx, which is PTR_TO_STACK) to a stack location to free up those two
	registers..

    Output scratch buffer
    ---------------------
	The output scratch buffer is a block of contiguous memory that is used
	to construct the output record for a D clause.  The memory must be
	64-bit aligned.  The ECB id will be stored at offset 0, followed by the
	actual trace data items.  Numeric values are stored as 64-bit integers,
	and strings are stored as a size (a 8, 16, 32, or 64 bit integer)
	followed by the character array of the given size.

    Program structure
    -----------------
	Prologue:
		- Construct a struct dt_bpf_context with the ECB id, probe id,
		  register set content if available), and optional probe
		  arguments (up to 10).
		- Retrieve the per-CPU ouptut scratch buffer, ensure it is not
		  NULL, and assign it to %r9.

	Actions:
		- Each action is either data producing or computational in
		  nature.  Each action is compiled into its own code fragment,
		  with the assumption that at the start of the action all
		  registers are available (except %r9).  Values cannot be
		  considered retained from one action to the next.

	Epilogue:
		- If a fault occured, end the progran.
		- Call bpf_perf_event_output() to write the trace data record
		  into the ring-buffer for the current CPU..
