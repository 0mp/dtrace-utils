BPF MAPS
--------
Local variable storage
	array map (indexed by variable id)

Global and dynamic variable storage
	hash map (indexed by variable name)

Session state
	array map (indexed by state parameter id)

Probe meta data
	array map (indexed by probe id)

Context map
	array map (indexed by CPU id)

PROBE NAME HASHING
------------------
Legacy DTrace currently reports:
	   13 distinct providers
	   84 distinct modules
	42405 distinct functions
	  742 distinct probe names
	88928 distinct probes

Hash by module name, function name, probe name, and mod:func:name.  When doing
a string constant lookup of any element, use the hashtable for that element.
When doing a shell wildcard pattern match, iterate over all hash buckets by
iterating over the hash slots, and for each non-empty hash slot, iterate over
the buckets linked to that slot, applying the wildcard pattern to the string
value for which the bucket was created.

OPERATIONS
----------
    List probes (-l)
    ----------------
	This argument (mutually exclusive with -A, -G, -h, -V) requests a list
	of probes that match the probe specifications found in the provided
	script or command line actions.

	The probe specifications are given in the following format:

		[ [ [ <gstr> : ] <gstr> : ] <gstr> : ] <gstr>

	where
		<gstr> is either a string constant or a shell wildcard pattern
		       (an empty string is the same as a * pattern)

    Version (-V)
    ------------
	This argument (mutually exclusive with -A, -G, -h, -l) is used to
	display the DTrace API version inforamtion.  When verbose output is
	requested (-v), information about the DTrace application version and
	version control identifiers is included as well.

DTRACE BPF PROGRAM CONVENTIONS
------------------------------
    Output scratch buffer
    ---------------------
	The output scratch buffer is a block of contiguous memory that is used
	to construct the output record for a D clause.  The memory must be
	64-bit aligned.  The ECB id will be stored as a 32-bit value at offset
	0, followed by a 32-bit padding, and then the actual trace data items.
	Numeric values are stored as 64-bit integers, and strings are stored as
	a size (a 64 bit integer) followed by a character array of the given
	size.

    BPF function implementing a predicate
    -------------------------------------
	The BPF function that implements a specific D clause predicate has the
	following prototype:

		int dt_predicate(void *ctx, struct dt_bpf_context *dctx)

    BPF function implementing a D clause
    ------------------------------------
	The BPF function that implements a specific D clause has the following
	prototype:

		int dt_program(void *ctx, struct dt_bpf_context *dctx)

	Reserved registers
	------------------
	    %r9		pointer to the output buffer
	    %r8		offset of next available position in the output buffer

	Stack layout
        ------------
	    %fp-8	Pointer to BPF context (ctx)
	    %fp-16	Pointer to DTrace context (dctx)
	    %fp-24	Current CPU id
	    %fp-32	Spill slot for %r1
	    %fp-40	Spill slot for %r2
	    %fp-48	Spill slot for %r3
	    %fp-56	Spill slot for %r4
	    %fp-64	Spill slot for %r5
	    %fp-72	Spill slot for %r6
	    %fp-80	Spill slot for %r7

	    %fp-88	Storage for local variables (scalars are stored by
		through		value, strings and arrays by offset into the
	    %fp-256		real storage area)		[22 values]

	    %fp-264	Storage for string loading/storing operations
		through		(if needed)			[256 bytes]
	    %fp-512

	Prologue
	--------
	The BPF function generated by the DTrace compiler must save the BPF
	context passed in %r1 (ctx, which is PTR_TO_CTX) and the DTrace context
	passed in %r2 (dctx, which is PTR_TO_STACK) to the stack to free up
	those two registers because they will be needed in function calls.
	(Storing these pointers in memory obtained as a mpa value is not useful
	because the BPF verifier cannot track pointers unless they are stored
	in registers or to the stack (spilled register).

	Next, the bpf_get_smp_processor_id() BPF helper is called to obtain the
	current CPU id (i.e. the CPU on which the probe fired).  The value is
	stored to the stack so it can be used later in the epilogue as well.

	The prologue retrieves the output data buffer as the value associated
	with the current CPU id as key in the 'mem' BPF map, and verifies that
	the buffer exists.  If not, an error condition must be flagged in the
	global probe state.  We cannot trigger an ERROR probe invocation
	because that would require the output data buffer to be available in
	order to record the ERROR probe firing.

	The prologue records the epid (and 4 bytes of padding) into the output
	buffer.

		stxdw [%fp+-8], %r1		; store BPF context
		stxdw [%fp+-16], %r2		; store DTrace context

		call bpf_get_smp_processor_id
		lsh %r0, 0x20
		arsh %r0, 0x20
		stxw [%fp+-24], %r0		; store CPU id

		lddw %r1, &mem			; map_lookup_elem(&mem,
		mov %r2, %fp
		add %r2, -24			;		  &key)
		call bpf_map_lookup_elem
		mov %r9, %r0

		 * We need to add a test to make sure the value is not NULL,
		 * and if it is, we need to jump to code that handles this.

		ldxw %r0, [%r2+0]		; dctx->epid
		stxw [%r9+0], %r0		; buf[0..3] = epid
		stxw [%r9+4], 0			; buf[4..7] = 0

	Epilogue
	--------
	The epilogue of a BPF function that implements a D clause must check
	whether a fault was flagged during the execution of the clause.  If so,
	an ERROR probe was reported back to userspace and any data that is
	recorded for the current probe firing must be discarded.  The fault
	code will be returned from the BPF function.

	If no fault occured, the probe data is written to the perf output
	buffer for the current CPU, and the function returns 0.

		ldxdw %r0, [%fp+-16]	; load dctx from stack
		ldxdw %r0, [%r0+8]	; load content of dctx->fault
		jne %r0, 0, 10		; jump if not zero (fault)

		ldxdw %r1, [%fp+-8]	; bpf_perf_event_output(ctx,
		lddw %r2, &buffers	; 	buffers,
		ldxw %r3, [%fp+-24]	;	cpu,
		mov %r4, %r9		;	&buf,
		mov %r5, %r8		;	offset)
		call bpf_perf_event_output

		exit

    BPF trampoline (probe specific)
    -------------------------------
	Function Boundary Tracing (based on kprobe)
	-------------------------------------------
	The C equivalent implementation of the FBT trampoline program is:

		int dt_fbt(struct pt_regs *regs)
		{
			struct dt_bpf_context	dctx;

			memset(&dctx, 0, sizeof(dctx));
			dctx.epid = EPID;
			dctx.regs = *regs;
			dctx.argv[0] = PT_REGS_PARAM1(regs);
			dctx.argv[1] = PT_REGS_PARAM2(regs);
			dctx.argv[2] = PT_REGS_PARAM3(regs);
			dctx.argv[3] = PT_REGS_PARAM4(regs);
			dctx.argv[4] = PT_REGS_PARAM5(regs);
			dctx.argv[5] = PT_REGS_PARAM6(regs);

		#if defined(HAS_PREDICATE)
			if (!dt_predicate(regs, dctx))
				return 0;
		#endif
			return dt_program(regs, dctx);
		}

	Statically Defined Tracing (based on tracepoints)
	--------------------------------------------------
	The C equivalent implementation of the FBT trampoline program is:

		int dt_sdt(void)
		{
			struct dt_bpf_context	dctx;

			memset(&dctx, 0, sizeof(dctx));
			dctx.epid = EPID;

		#if defined(HAS_PREDICATE)
			if (!dt_predicate(regs, dctx))
				return 0;
		#endif
			return dt_program(regs, dctx);
		}

	System Call Tracing (based on tracepoints)
	-------------------------------------------
	The C equivalent implementation of the FBT trampoline program is:

		struct syscall_data {
			struct pt_regs *regs;
			long		syscall_nr;
			long		arg[6];
		};

		int dt_syscall(struct syscall_data *scd)
		{
			struct dt_bpf_context	dctx;
			int			i;

			memset(&dctx, 0, sizeof(dctx));
			dctx.epid = EPID;
			for (i = 0; i < ARGC; i++)
				dctx.argv[i] = scd->arg[i];

		#if defined(HAS_PREDICATE)
			if (!dt_predicate(regs, dctx))
				return 0;
		#endif
			return dt_program(regs, dctx);
		}
