diff -urN ../linux-2.6.34/init/Kconfig ./init/Kconfig
--- ../linux-2.6.34/init/Kconfig	2010-07-28 17:48:29.000000000 -0400
+++ ./init/Kconfig	2010-08-19 00:33:47.000000000 -0400
@@ -1100,6 +1100,8 @@
 	  Say Y here to enable the extended profiling support mechanisms used
 	  by profilers such as OProfile.
 
+source "kernel/dtrace/Kconfig"
+
 #
 # Place an empty function call at each tracepoint site. Can be
 # dynamically changed for a probe function.
diff -urN ../linux-2.6.34/kernel/dtrace/cyclic.c ./kernel/dtrace/cyclic.c
--- ../linux-2.6.34/kernel/dtrace/cyclic.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/cyclic.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,15 @@
+/*
+ * FILE:	dtrace_state.c
+ * DESCRIPTION:	Dynamic Tracing: consumer state functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include "cyclic.h"
+
+/*
+ * Remove the specific cyclic from the system.
+ */
+void cyclic_remove(cyclic_id_t id)
+{
+}
diff -urN ../linux-2.6.34/kernel/dtrace/cyclic.h ./kernel/dtrace/cyclic.h
--- ../linux-2.6.34/kernel/dtrace/cyclic.h	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/cyclic.h	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,12 @@
+#ifndef _CYCLIC_H_
+#define _CYCLIC_H_
+
+#include <linux/types.h>
+
+typedef uintptr_t	cyclic_id_t;
+
+#define CYCLIC_NONE	((cyclic_id_t)0)
+
+extern void cyclic_remove(cyclic_id_t);
+
+#endif /* _CYCLIC_H_ */
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_actdesc.c ./kernel/dtrace/dtrace_actdesc.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_actdesc.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_actdesc.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,62 @@
+/*
+ * FILE:	dtrace_actdesc.c
+ * DESCRIPTION:	Dynamic Tracing: action description functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+dtrace_actdesc_t *dtrace_actdesc_create(dtrace_actkind_t kind, uint32_t ntuple,
+					uint64_t uarg, uint64_t arg)
+{
+	dtrace_actdesc_t	*act;
+
+	ASSERT(!DTRACEACT_ISPRINTFLIKE(kind) ||
+	       (arg != NULL && arg >= KERNELBASE) ||
+	       (arg == NULL && kind == DTRACEACT_PRINTA));
+
+	act = kzalloc(sizeof (dtrace_actdesc_t), GFP_KERNEL);
+	act->dtad_kind = kind;
+	act->dtad_ntuple = ntuple;
+	act->dtad_uarg = uarg;
+	act->dtad_arg = arg;
+	act->dtad_refcnt = 1;
+
+	return act;
+}
+
+void dtrace_actdesc_hold(dtrace_actdesc_t *act)
+{
+	ASSERT(act->dtad_refcnt >= 1);
+
+	act->dtad_refcnt++;
+}
+
+void dtrace_actdesc_release(dtrace_actdesc_t *act, dtrace_vstate_t *vstate)
+{
+	dtrace_actkind_t	kind = act->dtad_kind;
+	dtrace_difo_t		*dp;
+
+	ASSERT(act->dtad_refcnt >= 1);
+
+	if (--act->dtad_refcnt != 0)
+		return;
+
+	if ((dp = act->dtad_difo) != NULL)
+		dtrace_difo_release(dp, vstate);
+
+	if (DTRACEACT_ISPRINTFLIKE(kind)) {
+		char	*str = (char *)(uintptr_t)act->dtad_arg;
+
+		ASSERT((str != NULL && (uintptr_t)str >= KERNELBASE) ||
+		       (str == NULL && act->dtad_kind == DTRACEACT_PRINTA));
+
+		if (str != NULL)
+			kfree(str);
+	}
+
+	kfree(act);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_anon.c ./kernel/dtrace/dtrace_anon.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_anon.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_anon.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,10 @@
+/*
+ * FILE:	dtrace_anon.c
+ * DESCRIPTION:	Dynamic Tracing: anonymous enabling functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include "dtrace.h"
+
+dtrace_anon_t	dtrace_anon;
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_buffer.c ./kernel/dtrace/dtrace_buffer.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_buffer.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_buffer.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,36 @@
+/*
+ * FILE:	dtrace_buffer.c
+ * DESCRIPTION:	Dynamic Tracing: buffer functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+void dtrace_buffer_free(dtrace_buffer_t *bufs)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		dtrace_buffer_t	*buf = &bufs[cpu];
+
+		if (buf->dtb_tomax == NULL) {
+			ASSERT(buf->dtb_xamot == NULL);
+			ASSERT(buf->dtb_size == 0);
+
+			continue;
+		}
+
+		if (buf->dtb_xamot != NULL) {
+			ASSERT(!(buf->dtb_flags & DTRACEBUF_NOSWITCH));
+
+			kfree(buf->dtb_xamot);
+		}
+
+		kfree(buf->dtb_tomax);
+		buf->dtb_size = 0;
+		buf->dtb_tomax = NULL;
+	}
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_dev.c ./kernel/dtrace/dtrace_dev.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_dev.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_dev.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,360 @@
+/*
+ * FILE:	dtrace_dev.c
+ * DESCRIPTION:	Dynamic Tracing: device file handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+
+uint32_t			dtrace_helptrace_next = 0;
+uint32_t			dtrace_helptrace_nlocals;
+char				*dtrace_helptrace_buffer;
+int				dtrace_helptrace_bufsize = 512 * 1024;
+
+#ifdef DEBUG
+int				dtrace_helptrace_enabled = 1;
+#else
+int				dtrace_helptrace_enabled = 0;
+#endif
+
+int				dtrace_opens;
+
+dtrace_pops_t			dtrace_provider_ops = {
+	(void (*)(void *, const dtrace_probedesc_t *))dtrace_nullop,
+	(void (*)(void *, struct module *))dtrace_nullop,
+	(int (*)(void *, dtrace_id_t, void *))dtrace_enable_nullop,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	NULL,
+	NULL,
+	NULL,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop
+};
+
+static size_t			dtrace_retain_max = 1024;
+
+static dtrace_id_t		dtrace_probeid_begin;
+static dtrace_id_t		dtrace_probeid_end;
+static dtrace_id_t		dtrace_probeid_error;
+
+static dtrace_toxrange_t	*dtrace_toxrange;
+static int			dtrace_toxranges;
+static int			dtrace_toxranges_max;
+
+static dtrace_pattr_t		dtrace_provider_attr = {
+{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
+};
+
+void dtrace_nullop(void)
+{
+}
+
+int dtrace_enable_nullop(void)
+{
+	return 0;
+}
+
+static long dtrace_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int dtrace_open(struct inode *inode, struct file *file)
+{
+	dtrace_state_t	*state;
+	uint32_t	priv;
+	uid_t		uid;
+
+	dtrace_cred2priv(file->f_cred, &priv, &uid);
+	if (priv == DTRACE_PRIV_NONE)
+		return -EACCES;
+
+	mutex_lock(&dtrace_provider_lock);
+	dtrace_probe_provide(NULL, NULL);
+	mutex_unlock(&dtrace_provider_lock);
+
+	/* FIXME: mutex_lock(&cpu_lock); */
+	mutex_lock(&dtrace_lock);
+	dtrace_opens++;
+	dtrace_membar_producer();
+
+#ifdef FIXME
+	/*
+	 * Is this relevant for Linux?  Is there an equivalent?
+	 */
+	if ((kdi_dtrace_set(KDI_DTSET_DTRACE_ACTIVATE) != 0) {
+		dtrace_opens--;
+		mutex_unlock(&cpu_lock);
+		mutex_unlock(&dtrace_lock);
+		return -EBUSY;
+	}
+#endif
+
+	state = dtrace_state_create(file);
+	/* FIXME: mutex_unlock(&cpu_lock); */
+
+	if (state == NULL) {
+#ifdef FIXME
+		if (--dtrace_opens == 0 && dtrace_anon.dta_enabling == NULL)
+			(void)kdi_dtrace_set(KDI_DTSET_DTRACE_DEACTIVATE);
+#endif
+
+		mutex_unlock(&dtrace_lock);
+
+		return -EAGAIN;
+	}
+
+	file->private_data = state;
+
+	mutex_unlock(&dtrace_lock);
+
+	return 0;
+}
+
+static int dtrace_close(struct inode *inode, struct file *file)
+{
+	dtrace_state_t	*state;
+
+	/* FIXME: mutex_lock(&cpu_lock); */
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * If there is anonymous state, destroy that first.
+	 */
+	state = file->private_data;
+	if (state->dts_anon) {
+		ASSERT(dtrace_anon.dta_state == NULL);
+
+		dtrace_state_destroy(state->dts_anon);
+	}
+
+	dtrace_state_destroy(state);
+	ASSERT(dtrace_opens > 0);
+
+#ifdef FIXME
+	if (--dtrace_opens == 0 && dtrace_anon.dta_enabling == NULL)
+		(void)kdi_dtrace_set(KDI_DTSET_DTRACE_DEACTIVATE);
+#endif
+
+	mutex_unlock(&dtrace_lock);
+	/* FIXME: mutex_unlock(&cpu_lock); */
+
+	return 0;
+}
+
+static const struct file_operations dtrace_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = dtrace_ioctl,
+        .open   = dtrace_open,
+        .release = dtrace_close,
+};
+
+static struct miscdevice dtrace_dev = {
+	.minor = DT_DEV_DTRACE_MINOR,
+	.name = "dtrace",
+	.nodename = "dtrace/dtrace",
+	.fops = &dtrace_fops,
+};
+
+/*
+ * Register a toxic range.
+ */
+static void dtrace_toxrange_add(uintptr_t base, uintptr_t limit)
+{
+	if (dtrace_toxranges >= dtrace_toxranges_max) {
+		int			osize, nsize;
+		dtrace_toxrange_t	*range;
+
+		osize = dtrace_toxranges_max * sizeof (dtrace_toxrange_t);
+
+		if (osize == 0) {
+			ASSERT(dtrace_toxrange == NULL);
+			ASSERT(dtrace_toxranges_max == 0);
+
+			dtrace_toxranges_max = 1;
+		} else
+			dtrace_toxranges_max <<= 1;
+
+		nsize = dtrace_toxranges_max * sizeof (dtrace_toxrange_t);
+		range = kzalloc(nsize, GFP_KERNEL);
+
+		if (dtrace_toxrange != NULL) {
+			ASSERT(osize != 0);
+
+			memcpy(range, dtrace_toxrange, osize);
+			kfree(dtrace_toxrange);
+		}
+
+		dtrace_toxrange = range;
+	}
+
+	ASSERT(dtrace_toxrange[dtrace_toxranges].dtt_base == (uintptr_t)NULL);
+	ASSERT(dtrace_toxrange[dtrace_toxranges].dtt_limit == (uintptr_t)NULL);
+
+	dtrace_toxrange[dtrace_toxranges].dtt_base = base;
+	dtrace_toxrange[dtrace_toxranges].dtt_limit = limit;
+	dtrace_toxranges++;
+}
+
+/*
+ * Initialize the DTrace core.
+ *
+ * Equivalent to: dtrace_attach()
+ */
+int dtrace_dev_init(void)
+{
+	dtrace_provider_id_t	id;
+	int			rc = 0;
+
+	/* FIXME: mutex_lock(&cpu_lock); */
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * Register the device for the DTrace core.
+	 */
+	rc = misc_register(&dtrace_dev);
+	if (rc) {
+		pr_err("%s: Can't register misc device %d\n",
+		       dtrace_dev.name, dtrace_dev.minor);
+
+		/* FIXME: mutex_unlock(&cpu_lock); */
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_provider_lock);
+
+		return rc;
+	}
+
+#ifdef FIXME
+	dtrace_modload = dtrace_module_loaded;
+	dtrace_modunload = dtrace_module_unloaded;
+	dtrace_cpu_init = dtrace_cpu_setup_initial;
+	dtrace_helpers_cleanup = dtrace_helpers_destroy;
+	dtrace_helpers_fork = dtrace_helpers_duplicate;
+	dtrace_cpustart_init = dtrace_suspend;
+	dtrace_cpustart_fini = dtrace_resume;
+	dtrace_debugger_init = dtrace_suspend;
+	dtrace_debugger_fini = dtrace_resume;
+
+	register_cpu_setup_func((cpu_setup_func_t *)dtrace_cpu_setup, NULL);
+#endif
+
+	idr_init(&dtrace_probe_idr);
+
+#ifdef FIXME
+	dtrace_taskq = taskq_create("dtrace_taskq", 1, maxclsyspri, 1, INT_MAX,
+				    0);
+#endif
+
+	dtrace_state_cache = kmem_cache_create("dtrace_state_cache",
+				sizeof (dtrace_dstate_percpu_t) * NR_CPUS,
+				__alignof__(dtrace_dstate_percpu_t),
+				SLAB_PANIC, NULL);
+
+	/*
+	 * Create the probe hashtables.
+	 */
+	dtrace_bymod = dtrace_hash_create(
+				offsetof(dtrace_probe_t, dtpr_mod),
+				offsetof(dtrace_probe_t, dtpr_nextmod),
+				offsetof(dtrace_probe_t, dtpr_prevmod));
+	dtrace_byfunc = dtrace_hash_create(
+				offsetof(dtrace_probe_t, dtpr_func),
+				offsetof(dtrace_probe_t, dtpr_nextfunc),
+				offsetof(dtrace_probe_t, dtpr_prevfunc));
+	dtrace_byname = dtrace_hash_create(
+				offsetof(dtrace_probe_t, dtpr_name),
+				offsetof(dtrace_probe_t, dtpr_nextname),
+				offsetof(dtrace_probe_t, dtpr_prevname));
+
+	/*
+	 * Ensure that the X configuration parameter has a legal value.
+	 */
+	if (dtrace_retain_max < 1) {
+		pr_warning("Illegal value (%lu) for dtrace_retain_max; "
+			   "setting to 1", (unsigned long)dtrace_retain_max);
+
+		dtrace_retain_max = 1;
+	}
+
+	/*
+	 * Discover our toxic ranges.
+	 */
+	dtrace_toxic_ranges(dtrace_toxrange_add);
+
+	/*
+	 * Register ourselves as a provider.
+	 */
+	(void)dtrace_register("dtrace", &dtrace_provider_attr,
+			      DTRACE_PRIV_NONE, 0, &dtrace_provider_ops, NULL,
+			      &id);
+
+	ASSERT(dtrace_provider != NULL);
+	ASSERT((dtrace_provider_id_t)dtrace_provider == id);
+
+	/*
+	 * Create BEGIN, END, and ERROR probes.
+	 */
+	dtrace_probeid_begin = dtrace_probe_create(
+				(dtrace_provider_id_t)dtrace_provider, NULL,
+				NULL, "BEGIN", 0, NULL);
+	dtrace_probeid_end = dtrace_probe_create(
+				(dtrace_provider_id_t)dtrace_provider, NULL,
+				NULL, "END", 0, NULL);
+	dtrace_probeid_error = dtrace_probe_create(
+				(dtrace_provider_id_t)dtrace_provider, NULL,
+				NULL, "ERROR", 1, NULL);
+
+#ifdef FIXME
+	dtrace_anon_property();
+	mutex_unlock(&cpu_lock);
+#endif
+
+	/*
+	 * If DTrace helper tracing is enabled, we need to allocate a trace
+	 * buffer.
+	 */
+	if (dtrace_helptrace_enabled) {
+		ASSERT(dtrace_helptrace_buffer == NULL);
+
+		dtrace_helptrace_buffer = kzalloc(dtrace_helptrace_bufsize,
+						  GFP_KERNEL);
+		dtrace_helptrace_next = 0;
+	}
+
+#ifdef FIXME
+	/*
+	 * There is usually code here to handle the case where there already
+	 * are providers when we get to this code.  On Linux, that does not
+	 * seem to be possible since the DTrace core module (this code) is
+	 * loaded as a dependency for each provider, and thus this
+	 * initialization code is executed prior to the initialization code of
+	 * the first provider causing the core to be loaded.
+	 */
+#endif
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+
+	return 0;
+}
+
+void dtrace_dev_exit(void)
+{
+	misc_deregister(&dtrace_dev);
+
+	idr_destroy(&dtrace_probe_idr);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_dev.h ./kernel/dtrace/dtrace_dev.h
--- ../linux-2.6.34/kernel/dtrace/dtrace_dev.h	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_dev.h	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,16 @@
+#ifndef _DTRACE_DEV_H_
+#define _DTRACE_DEV_H_
+
+#define DT_DEV_DTRACE_MINOR	(16)
+#define DT_DEV_HELPER_MINOR	(DT_DEV_DTRACE_MINOR + 1)
+#define DT_DEV_PROFILE_MINOR	(DT_DEV_HELPER_MINOR + 1)
+#define DT_DEV_SYSTRACE_MINOR	(DT_DEV_PROFILE_MINOR + 1)
+#define DT_DEV_FBT_MINOR	(DT_DEV_SYSTRACE_MINOR + 1)
+#define DT_DEV_SDT_MINOR	(DT_DEV_FBT_MINOR + 1)
+#define DT_DEV_FASTTRAP_MINOR	(DT_DEV_SDT_MINOR + 1)
+#define DT_DEV_LOCKSTAT_MINOR	(DT_DEV_FASTTRAP_MINOR + 1)
+
+extern int dtrace_dev_init(void);
+extern void dtrace_dev_exit(void);
+
+#endif /* _DTRACE_DEV_H_ */
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_dif.c ./kernel/dtrace/dtrace_dif.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_dif.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_dif.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,113 @@
+/*
+ * FILE:	dtrace_dif.c
+ * DESCRIPTION:	Dynamic Tracing: DIF object functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+static uint64_t	dtrace_vtime_references;
+
+void dtrace_difo_hold(dtrace_difo_t *dp)
+{
+	int	i;
+
+	dp->dtdo_refcnt++;
+	ASSERT(dp->dtdo_refcnt != 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		dtrace_difv_t	*v = &dp->dtdo_vartab[i];
+
+		if (v->dtdv_id != DIF_VAR_VTIMESTAMP)
+			continue;
+
+		if (dtrace_vtime_references++ == 0)
+			dtrace_vtime_enable();
+	}
+}
+
+void dtrace_difo_destroy(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
+{
+	int	i;
+
+	ASSERT(dp->dtdo_refcnt == 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		dtrace_difv_t		*v = &dp->dtdo_vartab[i];
+		dtrace_statvar_t	*svar, **svarp;
+		uint_t			id;
+		uint8_t			scope = v->dtdv_scope;
+		int			*np;
+
+		switch (scope) {
+		case DIFV_SCOPE_THREAD:
+			continue;
+
+		case DIFV_SCOPE_LOCAL:
+			np = &vstate->dtvs_nlocals;
+			svarp = vstate->dtvs_locals;
+			break;
+
+		case DIFV_SCOPE_GLOBAL:
+			np = &vstate->dtvs_nglobals;
+			svarp = vstate->dtvs_globals;
+			break;
+
+		default:
+			BUG();
+		}
+
+		if ((id = v->dtdv_id) < DIF_VAR_OTHER_UBASE)
+			continue;
+
+		id -= DIF_VAR_OTHER_UBASE;
+		ASSERT(id < *np);
+
+		svar = svarp[id];
+		ASSERT(svar != NULL);
+		ASSERT(svar->dtsv_refcnt > 0);
+
+		if (--svar->dtsv_refcnt > 0)
+			continue;
+
+		if (svar->dtsv_size != 0) {
+			ASSERT((void *)(uintptr_t)svar->dtsv_data != NULL);
+			kfree((void *)(uintptr_t)svar->dtsv_data);
+		}
+
+		kfree(svar);
+		svarp[id] = NULL;
+	}
+
+	kfree(dp->dtdo_buf);
+        kfree(dp->dtdo_inttab);
+        kfree(dp->dtdo_strtab);
+        kfree(dp->dtdo_vartab);
+        kfree(dp);
+}
+
+void dtrace_difo_release(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
+{
+	int	i;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+	ASSERT(dp->dtdo_refcnt != 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		dtrace_difv_t *v = &dp->dtdo_vartab[i];
+
+		if (v->dtdv_id != DIF_VAR_VTIMESTAMP)
+			continue;
+
+		ASSERT(dtrace_vtime_references > 0);
+
+		if (--dtrace_vtime_references == 0)
+			dtrace_vtime_disable();
+	}
+
+	if (--dp->dtdo_refcnt == 0)
+		dtrace_difo_destroy(dp, vstate);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_ecb.c ./kernel/dtrace/dtrace_ecb.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_ecb.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_ecb.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,729 @@
+/*
+ * FILE:	dtrace_ecb.c
+ * DESCRIPTION:	Dynamic Tracing: ECB functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+dtrace_ecb_t	*dtrace_ecb_create_cache;
+
+static dtrace_action_t *dtrace_ecb_aggregation_create(dtrace_ecb_t *ecb,
+						      dtrace_actdesc_t *desc)
+{
+	dtrace_aggregation_t	*agg;
+	size_t			size = sizeof (uint64_t);
+	int			ntuple = desc->dtad_ntuple;
+	dtrace_action_t		*act;
+	dtrace_recdesc_t	*frec;
+	dtrace_aggid_t		aggid;
+	dtrace_state_t		*state = ecb->dte_state;
+
+	agg = kzalloc(sizeof (dtrace_aggregation_t), GFP_KERNEL);
+	agg->dtag_ecb = ecb;
+
+	ASSERT(DTRACEACT_ISAGG(desc->dtad_kind));
+
+	switch (desc->dtad_kind) {
+	case DTRACEAGG_MIN:
+		agg->dtag_initial = UINT64_MAX;
+		agg->dtag_aggregate = dtrace_aggregate_min;
+		break;
+
+	case DTRACEAGG_MAX:
+		agg->dtag_initial = UINT64_MIN;
+		agg->dtag_aggregate = dtrace_aggregate_max;
+		break;
+
+	case DTRACEAGG_COUNT:
+		agg->dtag_aggregate = dtrace_aggregate_count;
+		break;
+
+	case DTRACEAGG_QUANTIZE:
+		agg->dtag_aggregate = dtrace_aggregate_quantize;
+		size = (((sizeof (uint64_t) * NBBY) - 1) * 2 + 1) *
+		       sizeof (uint64_t);
+		break;
+
+	case DTRACEAGG_LQUANTIZE: {
+		uint16_t	step = DTRACE_LQUANTIZE_STEP(desc->dtad_arg);
+		uint16_t	levels =
+				DTRACE_LQUANTIZE_LEVELS(desc->dtad_arg);
+
+		agg->dtag_initial = desc->dtad_arg;
+		agg->dtag_aggregate = dtrace_aggregate_lquantize;
+
+		if (step == 0 || levels == 0)
+			goto err;
+
+		size = levels * sizeof (uint64_t) + 3 * sizeof (uint64_t);
+		break;
+	}
+
+	case DTRACEAGG_AVG:
+		agg->dtag_aggregate = dtrace_aggregate_avg;
+		size = sizeof (uint64_t) * 2;
+		break;
+
+	case DTRACEAGG_STDDEV:
+		agg->dtag_aggregate = dtrace_aggregate_stddev;
+		size = sizeof (uint64_t) * 4;
+		break;
+
+	case DTRACEAGG_SUM:
+		agg->dtag_aggregate = dtrace_aggregate_sum;
+		break;
+
+	default:
+		goto err;
+	}
+
+	agg->dtag_action.dta_rec.dtrd_size = size;
+
+	if (ntuple == 0)
+		goto err;
+
+	for (act = ecb->dte_action_last; act != NULL; act = act->dta_prev) {
+		if (DTRACEACT_ISAGG(act->dta_kind))
+			break;
+
+		if (--ntuple == 0) {
+			agg->dtag_first = act;
+			goto success;
+		}
+	}
+
+	ASSERT(ntuple != 0);
+err:
+	kfree(agg);
+	return NULL;
+
+success:
+	ASSERT(ecb->dte_action_last != NULL);
+	act = ecb->dte_action_last;
+
+	if (act->dta_kind == DTRACEACT_DIFEXPR) {
+		ASSERT(act->dta_difo != NULL);
+
+		if (act->dta_difo->dtdo_rtype.dtdt_size == 0)
+			agg->dtag_hasarg = 1;
+	}
+
+	/*
+	 * KVH FIXME: I am not too sure this is the best way to handle
+	 * aggregate ids.  Essentially, a 1 byte allocation is performed,
+	 * resulting in a unique virtual address that is converted into an
+	 * integer value and used as id.  On Linux, I believe that this
+	 * technique results in overhead due to the allocation.  I changed this
+	 * to use kmalloc to aovid the vmalloc overhead (since vmalloc aligns
+	 * all allocations on a page boundary).
+	 */
+	aggid = (dtrace_aggid_t)(uintptr_t)kmalloc(1, GFP_KERNEL);
+
+	if (aggid - 1 >= state->dts_naggregations) {
+		dtrace_aggregation_t	**oaggs = state->dts_aggregations;
+		dtrace_aggregation_t	**aggs;
+		int			naggs = state->dts_naggregations << 1;
+		int			onaggs = state->dts_naggregations;
+
+		ASSERT(aggid == state->dts_naggregations + 1);
+
+		if (naggs == 0) {
+			ASSERT(oaggs == NULL);
+
+			naggs = 1;
+		}
+
+		aggs = kzalloc(naggs * sizeof (*aggs), GFP_KERNEL);
+		if (oaggs != NULL) {
+			memcpy(oaggs, aggs, onaggs * sizeof (*aggs));
+			kfree(oaggs);
+		}
+
+		state->dts_aggregations = aggs;
+		state->dts_naggregations = naggs;
+	}
+
+	ASSERT(state->dts_aggregations[aggid - 1] == NULL);
+	state->dts_aggregations[(agg->dtag_id = aggid) - 1] = agg;
+
+	frec = &agg->dtag_first->dta_rec;
+	if (frec->dtrd_alignment < sizeof (dtrace_aggid_t))
+		frec->dtrd_alignment = sizeof (dtrace_aggid_t);
+
+	for (act = agg->dtag_first; act != NULL; act = act->dta_next) {
+		ASSERT(!act->dta_intuple);
+
+		act->dta_intuple = 1;
+	}
+
+	return &agg->dtag_action;
+}
+
+void dtrace_ecb_aggregation_destroy(dtrace_ecb_t *ecb, dtrace_action_t *act)
+{
+	dtrace_aggregation_t	*agg = (dtrace_aggregation_t *)act;
+	dtrace_state_t		*state = ecb->dte_state;
+	dtrace_aggid_t		aggid = agg->dtag_id;
+
+	ASSERT(DTRACEACT_ISAGG(act->dta_kind));
+	kfree(state->dts_aggid_arena);
+
+	ASSERT(state->dts_aggregations[aggid - 1] == agg);
+	state->dts_aggregations[aggid - 1] = NULL;
+
+	kfree(agg);
+}
+
+static int dtrace_ecb_action_add(dtrace_ecb_t *ecb, dtrace_actdesc_t *desc)
+{
+	dtrace_action_t		*action, *last;
+	dtrace_difo_t		*dp = desc->dtad_difo;
+	uint32_t		size = 0, align = sizeof (uint8_t), mask;
+	uint16_t		format = 0;
+	dtrace_recdesc_t	*rec;
+	dtrace_state_t		*state = ecb->dte_state;
+	dtrace_optval_t		*opt = state->dts_options, nframes, strsize;
+	uint64_t		arg = desc->dtad_arg;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+	ASSERT(ecb->dte_action == NULL || ecb->dte_action->dta_refcnt == 1);
+
+	if (DTRACEACT_ISAGG(desc->dtad_kind)) {
+		dtrace_action_t	*act;
+
+		for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+			if (act->dta_kind == DTRACEACT_COMMIT)
+				return -EINVAL;
+
+			if (act->dta_kind == DTRACEACT_SPECULATE)
+				return -EINVAL;
+		}
+
+		action = dtrace_ecb_aggregation_create(ecb, desc);
+		if (action == NULL)
+			return -EINVAL;
+	} else {
+		if (DTRACEACT_ISDESTRUCTIVE(desc->dtad_kind) ||
+		    (desc->dtad_kind == DTRACEACT_DIFEXPR &&
+		     dp != NULL && dp->dtdo_destructive))
+			state->dts_destructive = 1;
+
+		switch (desc->dtad_kind) {
+		case DTRACEACT_PRINTF:
+		case DTRACEACT_PRINTA:
+		case DTRACEACT_SYSTEM:
+		case DTRACEACT_FREOPEN:
+			if ((void *)(uintptr_t)arg == NULL) {
+				ASSERT(desc->dtad_kind == DTRACEACT_PRINTA);
+	
+				format = 0;
+			} else {
+				ASSERT((void *)(uintptr_t)arg != NULL);
+#ifdef FIXME
+				ASSERT(arg > KERNELBASE);
+#endif
+
+				format = dtrace_format_add(
+						state, (char *)(uintptr_t)arg);
+			}
+
+		case DTRACEACT_LIBACT:
+		case DTRACEACT_DIFEXPR:
+			if (dp == NULL)
+				return -EINVAL;
+
+			if ((size = dp->dtdo_rtype.dtdt_size) != 0)
+				break;
+
+			if (dp->dtdo_rtype.dtdt_kind == DIF_TYPE_STRING) {
+				if (!(dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+					return -EINVAL;
+
+				size = opt[DTRACEOPT_STRSIZE];
+			}
+
+			break;
+
+		case DTRACEACT_STACK:
+			if ((nframes = arg) == 0) {
+				nframes = opt[DTRACEOPT_STACKFRAMES];
+
+				ASSERT(nframes > 0);
+
+				arg = nframes;
+			}
+
+			size = nframes * sizeof (pc_t);
+			break;
+
+		case DTRACEACT_JSTACK:
+			if ((strsize = DTRACE_USTACK_STRSIZE(arg)) == 0)
+				strsize = opt[DTRACEOPT_JSTACKSTRSIZE];
+
+			if ((nframes = DTRACE_USTACK_NFRAMES(arg)) == 0)
+				nframes = opt[DTRACEOPT_JSTACKFRAMES];
+
+			arg = DTRACE_USTACK_ARG(nframes, strsize);
+
+		case DTRACEACT_USTACK:
+			if (desc->dtad_kind != DTRACEACT_JSTACK &&
+			    (nframes = DTRACE_USTACK_NFRAMES(arg)) == 0) {
+				strsize = DTRACE_USTACK_STRSIZE(arg);
+				nframes = opt[DTRACEOPT_USTACKFRAMES];
+
+				ASSERT(nframes > 0);
+
+				arg = DTRACE_USTACK_ARG(nframes, strsize);
+			}
+
+			size = (nframes + 1) * sizeof (uint64_t);
+			size += DTRACE_USTACK_STRSIZE(arg);
+			size = P2ROUNDUP(size, (uint32_t)(sizeof (uintptr_t)));
+
+			break;
+
+		case DTRACEACT_SYM:
+		case DTRACEACT_MOD:
+			if (dp == NULL || ((size = dp->dtdo_rtype.dtdt_size) !=
+					   sizeof (uint64_t)) ||
+			    (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+				return -EINVAL;
+
+			break;
+
+		case DTRACEACT_USYM:
+		case DTRACEACT_UMOD:
+		case DTRACEACT_UADDR:
+			if (dp == NULL ||
+			    (dp->dtdo_rtype.dtdt_size != sizeof (uint64_t)) ||
+			    (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+				return -EINVAL;
+
+			size = 2 * sizeof (uint64_t);
+
+			break;
+
+		case DTRACEACT_STOP:
+		case DTRACEACT_BREAKPOINT:
+		case DTRACEACT_PANIC:
+			break;
+
+		case DTRACEACT_CHILL:
+		case DTRACEACT_DISCARD:
+		case DTRACEACT_RAISE:
+			if (dp == NULL)
+				return -EINVAL;
+
+			break;
+
+		case DTRACEACT_EXIT:
+			if (dp == NULL || (size = dp->dtdo_rtype.dtdt_size) !=
+					   sizeof (int) ||
+			    (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+				return -EINVAL;
+
+			break;
+
+		case DTRACEACT_SPECULATE:
+			if (ecb->dte_size > sizeof (dtrace_epid_t))
+				return -EINVAL;
+
+			if (dp == NULL)
+				return -EINVAL;
+
+			state->dts_speculates = 1;
+
+			break;
+
+		case DTRACEACT_COMMIT: {
+			dtrace_action_t	*act = ecb->dte_action;
+
+			for (; act != NULL; act = act->dta_next) {
+				if (act->dta_kind == DTRACEACT_COMMIT)
+					return -EINVAL;
+			}
+
+			if (dp == NULL)
+				return -EINVAL;
+
+			break;
+		}
+
+		default:
+			return -EINVAL;
+		}
+
+		if (size != 0 || desc->dtad_kind == DTRACEACT_SPECULATE) {
+			dtrace_action_t	*act = ecb->dte_action;
+
+			for (; act != NULL; act = act->dta_next) {
+				if (act->dta_kind == DTRACEACT_COMMIT)
+					return -EINVAL;
+			}
+		}
+
+		action = kzalloc(sizeof (dtrace_action_t), GFP_KERNEL);
+		action->dta_rec.dtrd_size = size;
+	}
+
+	action->dta_refcnt = 1;
+	rec = &action->dta_rec;
+	size = rec->dtrd_size;
+
+	for (mask = sizeof (uint64_t) - 1; size != 0 && mask > 0; mask >>= 1) {
+		if (!(size & mask)) {
+			align = mask + 1;
+
+			break;
+		}
+	}
+
+	action->dta_kind = desc->dtad_kind;
+
+	if ((action->dta_difo = dp) != NULL)
+		dtrace_difo_hold(dp);
+
+	rec->dtrd_action = action->dta_kind;
+	rec->dtrd_arg = arg;
+	rec->dtrd_uarg = desc->dtad_uarg;
+	rec->dtrd_alignment = (uint16_t)align;
+	rec->dtrd_format = format;
+
+	if ((last = ecb->dte_action_last) != NULL) {
+		ASSERT(ecb->dte_action != NULL);
+
+		action->dta_prev = last;
+		last->dta_next = action;
+	} else {
+		ASSERT(ecb->dte_action == NULL);
+
+		ecb->dte_action = action;
+	}
+
+	ecb->dte_action_last = action;
+
+	return 0;
+}
+
+static void dtrace_ecb_action_remove(dtrace_ecb_t *ecb)
+{
+	dtrace_action_t	*act = ecb->dte_action, *next;
+	dtrace_vstate_t	*vstate = &ecb->dte_state->dts_vstate;
+	dtrace_difo_t	*dp;
+	uint16_t	format;
+
+	if (act != NULL && act->dta_refcnt > 1) {
+		ASSERT(act->dta_next == NULL || act->dta_next->dta_refcnt == 1);
+
+		act->dta_refcnt--;
+	} else {
+		for (; act != NULL; act = next) {
+			next = act->dta_next;
+			ASSERT(next != NULL || act == ecb->dte_action_last);
+			ASSERT(act->dta_refcnt == 1);
+
+			if ((format = act->dta_rec.dtrd_format) != 0)
+				dtrace_format_remove(ecb->dte_state, format);
+
+			if ((dp = act->dta_difo) != NULL)
+				dtrace_difo_release(dp, vstate);
+
+			if (DTRACEACT_ISAGG(act->dta_kind))
+				dtrace_ecb_aggregation_destroy(ecb, act);
+			else
+				kfree(act);
+		}
+	}
+
+	ecb->dte_action = NULL;
+	ecb->dte_action_last = NULL;
+	ecb->dte_size = sizeof (dtrace_epid_t);
+}
+
+/*
+ * Disable the ECB by removing it from its probe.
+ */
+void dtrace_ecb_disable(dtrace_ecb_t *ecb)
+{
+	dtrace_ecb_t	*pecb, *prev = NULL;
+	dtrace_probe_t	*probe = ecb->dte_probe;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+
+	if (probe == NULL)
+		return;
+
+	for (pecb = probe->dtpr_ecb; pecb != NULL; pecb = pecb->dte_next) {
+		if (pecb == ecb)
+			break;
+
+		prev = pecb;
+	}
+
+	ASSERT(pecb != NULL);
+
+	if (prev == NULL)
+		probe->dtpr_ecb = ecb->dte_next;
+	else
+		prev->dte_next = ecb->dte_next;
+
+	if (ecb == probe->dtpr_ecb_last) {
+		ASSERT(ecb->dte_next == NULL);
+		probe->dtpr_ecb_last = prev;
+	}
+
+	/*
+	 * The ECB has been disconnected from the probe; now sync to assure
+	 * that all CPUs have seen the change before returning.
+	 */
+	dtrace_sync();
+
+	if (probe->dtpr_ecb == NULL) {
+		/*
+		 * That was the last ECB on the probe; clear the predicate
+		 * cache ID for the probe, disable it and sync one more time
+		 * to assure that we'll never hit it again.
+		 */
+		dtrace_provider_t	*prov = probe->dtpr_provider;
+
+		ASSERT(ecb->dte_next == NULL);
+		ASSERT(probe->dtpr_ecb_last == NULL);
+
+		probe->dtpr_predcache = DTRACE_CACHEIDNONE;
+		prov->dtpv_pops.dtps_disable(prov->dtpv_arg,
+		probe->dtpr_id, probe->dtpr_arg);
+
+		dtrace_sync();
+	} else {
+		/*
+		 * There is at least one ECB remaining on the probe.  If there
+		 * is _exactly_ one, set the probe's predicate cache ID to be
+		 * the predicate cache ID of the remaining ECB.
+		 */
+		ASSERT(probe->dtpr_ecb_last != NULL);
+		ASSERT(probe->dtpr_predcache == DTRACE_CACHEIDNONE);
+
+		if (probe->dtpr_ecb == probe->dtpr_ecb_last) {
+			dtrace_predicate_t	*p =
+						probe->dtpr_ecb->dte_predicate;
+
+			ASSERT(probe->dtpr_ecb->dte_next == NULL);
+
+			if (p != NULL)
+				probe->dtpr_predcache = p->dtp_cacheid;
+		}
+
+		ecb->dte_next = NULL;
+	}
+}
+
+static dtrace_ecb_t *dtrace_ecb_add(dtrace_state_t *state,
+				    dtrace_probe_t *probe)
+{
+	dtrace_ecb_t	*ecb;
+	dtrace_epid_t	epid;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+
+	ecb = kzalloc(sizeof (dtrace_ecb_t), GFP_KERNEL);
+	ecb->dte_predicate = NULL;
+	ecb->dte_probe = probe;
+	ecb->dte_size = ecb->dte_needed = sizeof (dtrace_epid_t);
+	ecb->dte_alignment = sizeof (dtrace_epid_t);
+
+	epid = state->dts_epid++;
+
+	if (epid - 1 >= state->dts_necbs) {
+		dtrace_ecb_t	**oecbs = state->dts_ecbs, **ecbs;
+		int		necbs = state->dts_necbs << 1;
+
+		ASSERT(epid == state->dts_necbs + 1);
+
+		if (necbs == 0) {
+			ASSERT(oecbs == NULL);
+
+			necbs = 1;
+		}
+
+		ecbs = kcalloc(necbs, sizeof (*ecbs), GFP_KERNEL);
+
+
+		if (oecbs != NULL)
+			memcpy(oecbs, ecbs, state->dts_necbs * sizeof (*ecbs));
+
+		dtrace_membar_producer();
+
+		state->dts_ecbs = ecbs;
+
+		if (oecbs != NULL) {
+			if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE)
+				dtrace_sync();
+
+			kfree(oecbs);
+		}
+
+		dtrace_membar_producer();
+
+		state->dts_necbs = necbs;
+	}
+
+	ecb->dte_state = state;
+
+	ASSERT(state->dts_ecbs[epid - 1] == NULL);
+
+	dtrace_membar_producer();
+
+	state->dts_ecbs[(ecb->dte_epid = epid) - 1] = ecb;
+
+	return ecb;
+}
+
+static dtrace_ecb_t *dtrace_ecb_create(dtrace_state_t *state,
+				       dtrace_probe_t *probe,
+				       dtrace_enabling_t *enab)
+{
+	dtrace_ecb_t		*ecb;
+	dtrace_predicate_t	*pred;
+	dtrace_actdesc_t	*act;
+	dtrace_provider_t	*prov;
+	dtrace_ecbdesc_t	*desc = enab->dten_current;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+	ASSERT(state != NULL);
+
+	ecb = dtrace_ecb_add(state, probe);
+	ecb->dte_uarg = desc->dted_uarg;
+
+	if ((pred = desc->dted_pred.dtpdd_predicate) != NULL) {
+		dtrace_predicate_hold(pred);
+		ecb->dte_predicate = pred;
+	}
+
+	if (probe != NULL) {
+		prov = probe->dtpr_provider;
+
+		if (!(state->dts_cred.dcr_visible & DTRACE_CRV_ALLPROC) &&
+		    (prov->dtpv_priv.dtpp_flags & DTRACE_PRIV_USER))
+			ecb->dte_cond |= DTRACE_COND_OWNER;
+
+		if (!(state->dts_cred.dcr_visible & DTRACE_CRV_KERNEL) &&
+		    (prov->dtpv_priv.dtpp_flags & DTRACE_PRIV_KERNEL))
+			ecb->dte_cond |= DTRACE_COND_USERMODE;
+	}
+
+	if (dtrace_ecb_create_cache != NULL) {
+		dtrace_ecb_t	*cached = dtrace_ecb_create_cache;
+		dtrace_action_t	*act = cached->dte_action;
+
+		if (act != NULL) {
+			ASSERT(act->dta_refcnt > 0);
+
+			act->dta_refcnt++;
+			ecb->dte_action = act;
+			ecb->dte_action_last = cached->dte_action_last;
+			ecb->dte_needed = cached->dte_needed;
+			ecb->dte_size = cached->dte_size;
+			ecb->dte_alignment = cached->dte_alignment;
+		}
+
+		return ecb;
+	}
+
+	for (act = desc->dted_action; act != NULL; act = act->dtad_next) {
+		if ((enab->dten_error = dtrace_ecb_action_add(ecb, act)) != 0) {
+			dtrace_ecb_destroy(ecb);
+			return NULL;
+		}
+	}
+
+	dtrace_ecb_resize(ecb);
+
+	return (dtrace_ecb_create_cache = ecb);
+}
+
+int dtrace_ecb_create_enable(dtrace_probe_t *probe, void *arg)
+{
+	dtrace_ecb_t		*ecb;
+	dtrace_enabling_t	*enab = arg;
+	dtrace_state_t		*state = enab->dten_vstate->dtvs_state;
+
+	ASSERT(state != NULL);
+
+	if (probe != NULL && probe->dtpr_gen < enab->dten_probegen)
+		return DTRACE_MATCH_NEXT;
+
+	if ((ecb = dtrace_ecb_create(state, probe, enab)) == NULL)
+		return DTRACE_MATCH_DONE;
+
+	if (dtrace_ecb_enable(ecb) < 0)
+		return DTRACE_MATCH_FAIL;
+
+	return DTRACE_MATCH_NEXT;
+}
+
+void dtrace_ecb_destroy(dtrace_ecb_t *ecb)
+{
+	dtrace_state_t		*state = ecb->dte_state;
+	dtrace_vstate_t		*vstate = &state->dts_vstate;
+	dtrace_predicate_t	*pred;
+	dtrace_epid_t		epid = ecb->dte_epid;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+	ASSERT(ecb->dte_next == NULL);
+	ASSERT(ecb->dte_probe == NULL || ecb->dte_probe->dtpr_ecb != ecb);
+
+	if ((pred = ecb->dte_predicate) != NULL)
+		dtrace_predicate_release(pred, vstate);
+
+	dtrace_ecb_action_remove(ecb);
+
+	ASSERT(state->dts_ecbs[epid - 1] == ecb);
+	state->dts_ecbs[epid - 1] = NULL;
+
+	kfree(ecb);
+}
+
+void dtrace_ecb_resize(dtrace_ecb_t *ecb)
+{
+	/* INCOMPLETE */
+}
+
+int dtrace_ecb_enable(dtrace_ecb_t *ecb)
+{
+	dtrace_probe_t	*probe = ecb->dte_probe;
+
+	/* FIXME: ASSERT(mutex_is_locked(&cpu_lock)); */
+	ASSERT(mutex_is_locked(&dtrace_lock));
+	ASSERT(ecb->dte_next == NULL);
+
+	if (probe == NULL)
+		return 0;
+
+	if (probe->dtpr_ecb == NULL) {
+		dtrace_provider_t	*prov = probe->dtpr_provider;
+
+		probe->dtpr_ecb = probe->dtpr_ecb_last = ecb;
+
+
+		if (ecb->dte_predicate != NULL)
+			probe->dtpr_predcache = ecb->dte_predicate->dtp_cacheid;
+
+		return prov->dtpv_pops.dtps_enable(prov->dtpv_arg,
+						   probe->dtpr_id,
+						   probe->dtpr_arg);
+	} else {
+		ASSERT(probe->dtpr_ecb_last != NULL);
+
+		probe->dtpr_ecb_last->dte_next = ecb;
+		probe->dtpr_ecb_last = ecb;
+		probe->dtpr_predcache = 0;
+
+		dtrace_sync();
+
+		return 0;
+	}
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_enable.c ./kernel/dtrace/dtrace_enable.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_enable.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_enable.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,191 @@
+/*
+ * FILE:	dtrace_enable.c
+ * DESCRIPTION:	Dynamic Tracing: enabling functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+dtrace_enabling_t	*dtrace_retained;
+dtrace_genid_t		dtrace_retained_gen;
+
+void dtrace_enabling_destroy(dtrace_enabling_t *enab)
+{
+	int			i;
+	dtrace_ecbdesc_t	*ep;
+	dtrace_vstate_t		*vstate = enab->dten_vstate;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+
+	for (i = 0; i < enab->dten_ndesc; i++) {
+		dtrace_actdesc_t	*act, *next;
+		dtrace_predicate_t	*pred;
+
+		ep = enab->dten_desc[i];
+
+		if ((pred = ep->dted_pred.dtpdd_predicate) != NULL)
+			dtrace_predicate_release(pred, vstate);
+
+		for (act = ep->dted_action; act != NULL; act = next) {
+			next = act->dtad_next;
+			dtrace_actdesc_release(act, vstate);
+		}
+
+		kfree(ep);
+	}
+
+	kfree(enab->dten_desc);
+
+	/*
+	 * If this was a retained enabling, decrement the dts_nretained count
+	 * and remove it from the dtrace_retained list.
+	 */
+	if (enab->dten_prev != NULL || enab->dten_next != NULL ||
+	    dtrace_retained == enab) {
+		ASSERT(enab->dten_vstate->dtvs_state != NULL);
+		ASSERT(enab->dten_vstate->dtvs_state->dts_nretained > 0);
+		enab->dten_vstate->dtvs_state->dts_nretained--;
+		dtrace_retained_gen++;
+	}
+
+	if (enab->dten_prev == NULL) {
+		if (dtrace_retained == enab) {
+			dtrace_retained = enab->dten_next;
+
+			if (dtrace_retained != NULL)
+				dtrace_retained->dten_prev = NULL;
+		}
+	} else {
+		ASSERT(enab != dtrace_retained);
+		ASSERT(dtrace_retained != NULL);
+		enab->dten_prev->dten_next = enab->dten_next;
+	}
+
+	if (enab->dten_next != NULL) {
+		ASSERT(dtrace_retained != NULL);
+		enab->dten_next->dten_prev = enab->dten_prev;
+	}
+
+	kfree(enab);
+}
+
+void dtrace_enabling_retract(dtrace_state_t *state)
+{
+	dtrace_enabling_t	*enab, *next;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+
+	/*
+	 * Iterate over all retained enablings, destroy the enablings retained
+	 * for the specified state.
+	 */
+	for (enab = dtrace_retained; enab != NULL; enab = next) {
+		next = enab->dten_next;
+
+		/*
+		 * dtvs_state can only be NULL for helper enablings, and helper
+		 * enablings can't be retained.
+		 */
+		ASSERT(enab->dten_vstate->dtvs_state != NULL);
+
+		if (enab->dten_vstate->dtvs_state == state) {
+			ASSERT(state->dts_nretained > 0);
+			dtrace_enabling_destroy(enab);
+		}
+	}
+
+	ASSERT(state->dts_nretained == 0);
+}
+
+int dtrace_enabling_match(dtrace_enabling_t *enab, int *nmatched)
+{
+	int	i;
+	int	total_matched = 0, matched = 0;
+
+	for (i = 0; i < enab->dten_ndesc; i++) {
+		dtrace_ecbdesc_t	*ep = enab->dten_desc[i];
+
+		enab->dten_current = ep;
+		enab->dten_error = 0;
+
+		if ((matched = dtrace_probe_enable(&ep->dted_probe, enab)) < 0)
+			return -EBUSY;
+
+		total_matched += matched;
+
+		if (enab->dten_error != 0) {
+			if (nmatched == NULL)
+				pr_warning("dtrace_enabling_match() error on %p: %d\n", (void *)ep, enab->dten_error);
+
+			return enab->dten_error;
+		}
+	}
+
+	enab->dten_probegen = dtrace_probegen;
+	if (nmatched != NULL)
+		*nmatched = total_matched;
+
+	return 0;
+}
+
+void dtrace_enabling_matchall(void)
+{
+	dtrace_enabling_t	*enab;
+
+#ifdef FIXME
+	mutex_lock(&cpu_lock);
+#endif
+	mutex_lock(&dtrace_lock);
+
+	for (enab = dtrace_retained; enab != NULL; enab = enab->dten_next)
+		(void) dtrace_enabling_match(enab, NULL);
+
+	mutex_unlock(&dtrace_lock);
+#ifdef FIXME
+	mutex_unlock(&cpu_lock);
+#endif
+}
+
+void dtrace_enabling_provide(dtrace_provider_t *prv)
+{
+	int		all = 0;
+	dtrace_genid_t	gen;
+
+	if (prv == NULL) {
+		all = 1;
+		prv = dtrace_provider;
+	}
+
+	do {
+		dtrace_enabling_t	*enab;
+		void			*parg = prv->dtpv_arg;
+
+retry:
+		gen = dtrace_retained_gen;
+		for (enab = dtrace_retained; enab != NULL;
+		     enab = enab->dten_next) {
+			int	i;
+
+			for (i = 0; i < enab->dten_ndesc; i++) {
+				dtrace_probedesc_t	desc;
+
+				desc = enab->dten_desc[i]->dted_probe;
+				mutex_unlock(&dtrace_lock);
+				prv->dtpv_pops.dtps_provide(parg, &desc);
+				mutex_lock(&dtrace_lock);
+
+				if (gen != dtrace_retained_gen)
+					goto retry;
+			}
+		}
+	} while (all && (prv = prv->dtpv_next) != NULL);
+
+	mutex_unlock(&dtrace_lock);
+	dtrace_probe_provide(NULL, all ? NULL : prv);
+	mutex_lock(&dtrace_lock);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_fmt.c ./kernel/dtrace/dtrace_fmt.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_fmt.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_fmt.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,84 @@
+/*
+ * FILE:	dtrace_fmt.c
+ * DESCRIPTION:	Dynamic Tracing: format functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+uint16_t dtrace_format_add(dtrace_state_t *state, char *str)
+{
+	char		*fmt, **new;
+	uint16_t	ndx;
+
+	fmt = kstrdup(str, GFP_KERNEL);
+
+	for (ndx = 0; ndx < state->dts_nformats; ndx++) {
+		if (state->dts_formats[ndx] == NULL) {
+			state->dts_formats[ndx] = fmt;
+
+			return ndx + 1;
+		}
+	}
+
+	if (state->dts_nformats == UINT16_MAX) {
+		kfree(fmt);
+
+		return 0;
+	}
+
+	ndx = state->dts_nformats++;
+	new = kmalloc((ndx + 1) * sizeof (char *), GFP_KERNEL);
+
+	if (state->dts_formats != NULL) {
+		ASSERT(ndx != 0);
+		memcpy(new, state->dts_formats, ndx * sizeof (char *));
+		kfree(state->dts_formats);
+	}
+
+	state->dts_formats = new;
+	state->dts_formats[ndx] = fmt;
+
+	return ndx + 1;
+}
+
+void dtrace_format_remove(dtrace_state_t *state, uint16_t format)
+{
+	char	*fmt;
+
+	ASSERT(state->dts_formats != NULL);
+	ASSERT(format <= state->dts_nformats);
+	ASSERT(state->dts_formats[format - 1] != NULL);
+
+	fmt = state->dts_formats[format - 1];
+	kfree(fmt);
+	state->dts_formats[format - 1] = NULL;
+}
+
+void dtrace_format_destroy(dtrace_state_t *state)
+{
+	int	i;
+
+	if (state->dts_nformats == 0) {
+		ASSERT(state->dts_formats == NULL);
+		return;
+	}
+
+	ASSERT(state->dts_formats != NULL);
+
+	for (i = 0; i < state->dts_nformats; i++) {
+		char	*fmt = state->dts_formats[i];
+
+		if (fmt == NULL)
+			continue;
+
+		kfree(fmt);
+	}
+
+	kfree(state->dts_formats);
+	state->dts_nformats = 0;
+	state->dts_formats = NULL;
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace.h ./kernel/dtrace/dtrace.h
--- ../linux-2.6.34/kernel/dtrace/dtrace.h	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace.h	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,996 @@
+#ifndef _DTRACE_H_
+#define _DTRACE_H_
+
+#include <linux/cred.h>
+#include <linux/hrtimer.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/stringify.h>
+#include <asm/bitsperlong.h>
+#include <asm/ptrace.h>
+
+#include "cyclic.h"
+
+#define UINT16_MAX		(0xffff)
+#define UINT16_MIN		0
+#define UINT32_MAX		(0xffffffff)
+#define UINT32_MIN		0
+#define UINT64_MAX		(~0ULL)
+#define UINT64_MIN		(0)
+
+#define NBBY			(__BITS_PER_LONG / sizeof (long))
+
+#define SEC			1
+#define MILLISEC		1000
+#define MICROSEC		1000000
+#define NANOSEC			1000000000
+
+#define DIF_TYPE_CTF		0
+#define DIF_TYPE_STRING		1
+
+#define DIF_VAR_OTHER_MIN	0x0100
+#define DIF_VAR_OTHER_UBASE	0x0500
+#define DIF_VAR_OTHER_MAX	0xffff
+
+#define DIF_VAR_ARGS		0x0000
+#define DIF_VAR_REGS		0x0001
+#define DIF_VAR_UREGS		0x0002
+#define DIF_VAR_CURTHREAD	0x0100
+#define DIF_VAR_TIMESTAMP	0x0101
+#define DIF_VAR_VTIMESTAMP	0x0102
+#define DIF_VAR_IPL		0x0103
+#define DIF_VAR_EPID		0x0104
+#define DIF_VAR_ID		0x0105
+#define DIF_VAR_ARG0		0x0106
+#define DIF_VAR_ARG1		0x0107
+#define DIF_VAR_ARG2		0x0108
+#define DIF_VAR_ARG3		0x0109
+#define DIF_VAR_ARG4		0x010a
+#define DIF_VAR_ARG5		0x010b
+#define DIF_VAR_ARG6		0x010c
+#define DIF_VAR_ARG7		0x010d
+#define DIF_VAR_ARG8		0x010e
+#define DIF_VAR_ARG9		0x010f
+#define DIF_VAR_STACKDEPTH	0x0110
+#define DIF_VAR_CALLER		0x0111
+#define DIF_VAR_PROBEPROV	0x0112
+#define DIF_VAR_PROBEMOD	0x0113
+#define DIF_VAR_PROBEFUNC	0x0114
+#define DIF_VAR_PROBENAME	0x0115
+#define DIF_VAR_PID		0x0116
+#define DIF_VAR_TID		0x0117
+#define DIF_VAR_EXECNAME	0x0118
+#define DIF_VAR_ZONENAME	0x0119
+#define DIF_VAR_WALLTIMESTAMP	0x011a
+#define DIF_VAR_USTACKDEPTH	0x011b
+#define DIF_VAR_UCALLER		0x011c
+#define DIF_VAR_PPID		0x011d
+#define DIF_VAR_UID		0x011e
+#define DIF_VAR_GID		0x011f
+#define DIF_VAR_ERRNO		0x0120
+
+#define DIF_TF_BYREF		0x1
+
+#define DIFV_KIND_ARRAY		0
+#define DIFV_KIND_SCALAR	1
+
+#define DIFV_SCOPE_GLOBAL	0
+#define DIFV_SCOPE_THREAD	1
+#define DIFV_SCOPE_LOCAL	2
+
+#define DIFV_F_REF		0x1
+#define DIFV_F_MOD		0x2
+
+#define DTRACE_CPUALL		-1
+#define DTRACE_IDNONE		0
+#define DTRACE_EPIDNONE		0
+#define DTRACE_AGGIDNONE	0
+#define DTRACE_AGGVARIDNONE	0
+#define DTRACE_CACHEIDNONE	0
+#define DTRACE_PROVNONE		0
+#define DTRACE_METAPROVNONE	0
+#define DTRACE_ARGNONE		-1
+
+#define DTRACE_PROVNAMELEN	64
+#define DTRACE_MODNAMELEN	64
+#define DTRACE_FUNCNAMELEN	128
+#define DTRACE_NAMELEN		64
+
+#define DTRACE_ARGTYPELEN	128
+
+#define DTRACE_PROBEKEY_MAXDEPTH	8
+
+#define DTRACE_STABILITY_INTERNAL	0
+#define DTRACE_STABILITY_PRIVATE	1
+#define DTRACE_STABILITY_OBSOLETE	2
+#define DTRACE_STABILITY_EXTERNAL	3
+#define DTRACE_STABILITY_UNSTABLE	4
+#define DTRACE_STABILITY_EVOLVING	5
+#define DTRACE_STABILITY_STABLE		6
+#define DTRACE_STABILITY_STANDARD	7
+#define DTRACE_STABILITY_MAX		7
+
+#define DTRACE_CLASS_UNKNOWN	0
+#define DTRACE_CLASS_CPU	1
+#define DTRACE_CLASS_PLATFORM	2
+#define DTRACE_CLASS_GROUP	3
+#define DTRACE_CLASS_ISA	4
+#define DTRACE_CLASS_COMMON	5
+#define DTRACE_CLASS_MAX	5
+
+#define DTRACE_COND_OWNER	0x01
+#define DTRACE_COND_USERMODE	0x02
+
+#define DTRACE_CRA_PROC				0x0001
+#define DTRACE_CRA_PROC_CONTROL			0x0002
+#define DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER	0x0004
+#define DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG	0x0010
+#define DTRACE_CRA_KERNEL			0x0020
+#define DTRACE_CRA_KERNEL_DESTRUCTIVE		0x0040
+
+#define DTRACE_CRA_ALL		(DTRACE_CRA_PROC | \
+				 DTRACE_CRA_PROC_CONTROL | \
+				 DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER | \
+				 DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG | \
+				 DTRACE_CRA_KERNEL | \
+				 DTRACE_CRA_KERNEL_DESTRUCTIVE)
+
+#define DTRACE_CRV_ALLPROC	0x01
+#define DTRACE_CRV_KERNEL	0x02
+#define DTRACE_CRV_ALL		(DTRACE_CRV_ALLPROC | DTRACE_CRV_KERNEL)
+
+#define DTRACE_MATCH_FAIL	-1
+#define DTRACE_MATCH_NEXT	0
+#define DTRACE_MATCH_DONE	1
+
+#define DTRACE_PRIV_NONE	0x0000
+#define DTRACE_PRIV_KERNEL	0x0001
+#define DTRACE_PRIV_USER	0x0002
+#define DTRACE_PRIV_PROC	0x0004
+#define DTRACE_PRIV_OWNER	0x0008
+#define DTRACE_PRIV_ALL		(DTRACE_PRIV_KERNEL | DTRACE_PRIV_USER | \
+				 DTRACE_PRIV_PROC | DTRACE_PRIV_OWNER)
+
+#define DTRACE_QUANTIZE_NBUCKETS		\
+		(((sizeof (uint64_t) * NBBY) - 1) * 2 + 1)
+
+#define DTRACE_QUANTIZE_ZEROBUCKET	((sizeof (uint64_t) * NBBY) - 1)
+
+#define DTRACE_QUANTIZE_BUCKETVAL(buck)		\
+	(int64_t)((buck) < DTRACE_QUANTIZE_ZEROBUCKET ? \
+		  -(1LL << (DTRACE_QUANTIZE_ZEROBUCKET - 1 - (buck))) : \
+		  (buck) == DTRACE_QUANTIZE_ZEROBUCKET ? 0 : \
+		  1LL << ((buck) - DTRACE_QUANTIZE_ZEROBUCKET - 1))
+
+#define DTRACE_LQUANTIZE_STEPSHIFT	48
+#define DTRACE_LQUANTIZE_STEPMASK	((uint64_t)UINT16_MAX << 48)
+#define DTRACE_LQUANTIZE_LEVELSHIFT	32
+#define DTRACE_LQUANTIZE_LEVELMASK	((uint64_t)UINT16_MAX << 32)
+#define DTRACE_LQUANTIZE_BASESHIFT	0
+#define DTRACE_LQUANTIZE_BASEMASK	UINT32_MAX
+
+#define DTRACE_LQUANTIZE_STEP(x)		\
+		(uint16_t)(((x) & DTRACE_LQUANTIZE_STEPMASK) >> \
+			   DTRACE_LQUANTIZE_STEPSHIFT)
+
+#define DTRACE_LQUANTIZE_LEVELS(x)		\
+		(uint16_t)(((x) & DTRACE_LQUANTIZE_LEVELMASK) >> \
+			   DTRACE_LQUANTIZE_LEVELSHIFT)
+
+#define DTRACE_LQUANTIZE_BASE(x)		\
+		(int32_t)(((x) & DTRACE_LQUANTIZE_BASEMASK) >> \
+			  DTRACE_LQUANTIZE_BASESHIFT)
+
+#define DTRACE_USTACK_NFRAMES(x)	(uint32_t)((x) & UINT32_MAX)
+#define DTRACE_USTACK_STRSIZE(x)	(uint32_t)((x) >> 32)
+#define DTRACE_USTACK_ARG(x, y)		\
+		((((uint64_t)(y)) << 32) | ((x) & UINT32_MAX))
+
+#define DTRACEACT_NONE			0
+#define DTRACEACT_DIFEXPR		1
+#define DTRACEACT_EXIT			2
+#define DTRACEACT_PRINTF		3
+#define DTRACEACT_PRINTA		4
+#define DTRACEACT_LIBACT		5
+
+#define DTRACEACT_PROC			0x0100
+#define DTRACEACT_USTACK		(DTRACEACT_PROC + 1)
+#define DTRACEACT_JSTACK		(DTRACEACT_PROC + 2)
+#define DTRACEACT_USYM			(DTRACEACT_PROC + 3)
+#define DTRACEACT_UMOD			(DTRACEACT_PROC + 4)
+#define DTRACEACT_UADDR			(DTRACEACT_PROC + 5)
+
+#define DTRACEACT_PROC_DESTRUCTIVE	0x0200
+#define DTRACEACT_STOP			(DTRACEACT_PROC_DESTRUCTIVE + 1)
+#define DTRACEACT_RAISE			(DTRACEACT_PROC_DESTRUCTIVE + 2)
+#define DTRACEACT_SYSTEM		(DTRACEACT_PROC_DESTRUCTIVE + 3)
+#define DTRACEACT_FREOPEN		(DTRACEACT_PROC_DESTRUCTIVE + 4)
+
+#define DTRACEACT_PROC_CONTROL		0x0300
+
+#define DTRACEACT_KERNEL		0x0400
+#define DTRACEACT_STACK			(DTRACEACT_KERNEL + 1)
+#define DTRACEACT_SYM			(DTRACEACT_KERNEL + 2)
+#define DTRACEACT_MOD			(DTRACEACT_KERNEL + 3)
+
+#define DTRACEACT_KERNEL_DESTRUCTIVE	0x0500
+#define DTRACEACT_BREAKPOINT		(DTRACEACT_KERNEL_DESTRUCTIVE + 1)
+#define DTRACEACT_PANIC			(DTRACEACT_KERNEL_DESTRUCTIVE + 2)
+#define DTRACEACT_CHILL			(DTRACEACT_KERNEL_DESTRUCTIVE + 3)
+
+#define DTRACEACT_SPECULATIVE           0x0600
+#define DTRACEACT_SPECULATE		(DTRACEACT_SPECULATIVE + 1)
+#define DTRACEACT_COMMIT		(DTRACEACT_SPECULATIVE + 2)
+#define DTRACEACT_DISCARD		(DTRACEACT_SPECULATIVE + 3)
+
+#define DTRACEACT_AGGREGATION		0x0700
+#define DTRACEAGG_COUNT			(DTRACEACT_AGGREGATION + 1)
+#define DTRACEAGG_MIN			(DTRACEACT_AGGREGATION + 2)
+#define DTRACEAGG_MAX			(DTRACEACT_AGGREGATION + 3)
+#define DTRACEAGG_AVG			(DTRACEACT_AGGREGATION + 4)
+#define DTRACEAGG_SUM			(DTRACEACT_AGGREGATION + 5)
+#define DTRACEAGG_STDDEV		(DTRACEACT_AGGREGATION + 6)
+#define DTRACEAGG_QUANTIZE		(DTRACEACT_AGGREGATION + 7)
+#define DTRACEAGG_LQUANTIZE		(DTRACEACT_AGGREGATION + 8)
+
+#define DTRACEACT_CLASS(x)		((x) & 0xff00)
+
+#define DTRACEACT_ISAGG(x)		\
+		(DTRACEACT_CLASS(x) == DTRACEACT_AGGREGATION)
+
+#define DTRACEACT_ISDESTRUCTIVE(x)	\
+		(DTRACEACT_CLASS(x) == DTRACEACT_PROC_DESTRUCTIVE || \
+		 DTRACEACT_CLASS(x) == DTRACEACT_KERNEL_DESTRUCTIVE)
+
+#define DTRACEACT_ISSPECULATIVE(x)	\
+		(DTRACEACT_CLASS(x) == DTRACEACT_SPECULATIVE)
+
+#define DTRACEACT_ISPRINTFLIKE(x)	\
+		((x) == DTRACEACT_PRINTF || (x) == DTRACEACT_PRINTA || \
+		 (x) == DTRACEACT_SYSTEM || (x) == DTRACEACT_FREOPEN)
+
+#define DTRACEOPT_BUFSIZE	0
+#define DTRACEOPT_BUFPOLICY	1
+#define DTRACEOPT_DYNVARSIZE	2
+#define DTRACEOPT_AGGSIZE	3
+#define DTRACEOPT_SPECSIZE	4
+#define DTRACEOPT_NSPEC		5
+#define DTRACEOPT_STRSIZE	6
+#define DTRACEOPT_CLEANRATE	7
+#define DTRACEOPT_CPU		8
+#define DTRACEOPT_BUFRESIZE	9
+#define DTRACEOPT_GRABANON	10
+#define DTRACEOPT_FLOWINDENT	11
+#define DTRACEOPT_QUIET		12
+#define DTRACEOPT_STACKFRAMES	13
+#define DTRACEOPT_USTACKFRAMES	14
+#define DTRACEOPT_AGGRATE	15
+#define DTRACEOPT_SWITCHRATE	16
+#define DTRACEOPT_STATUSRATE	17
+#define DTRACEOPT_DESTRUCTIVE	18
+#define DTRACEOPT_STACKINDENT	19
+#define DTRACEOPT_RAWBYTES	20
+#define DTRACEOPT_JSTACKFRAMES	21
+#define DTRACEOPT_JSTACKSTRSIZE	22
+#define DTRACEOPT_AGGSORTKEY	23
+#define DTRACEOPT_AGGSORTREV	24
+#define DTRACEOPT_AGGSORTPOS	25
+#define DTRACEOPT_AGGSORTKEYPOS	26
+#define DTRACEOPT_MAX		27
+
+#define DTRACEOPT_UNSET		(dtrace_optval_t)-2
+
+#define DTRACEOPT_BUFPOLICY_RING	0
+#define DTRACEOPT_BUFPOLICY_FULL	1
+#define DTRACEOPT_BUFPOLICY_SWITCH	2
+
+#define DTRACEOPT_BUFRESIZE_AUTO	0
+#define DTRACEOPT_BUFRESIZE_MANUAL	1
+
+typedef uint8_t		dtrace_stability_t;
+typedef uint8_t		dtrace_class_t;
+
+typedef uint16_t	dtrace_actkind_t;
+
+typedef uint32_t	zoneid_t;	/* FIXME */
+typedef uint32_t	dif_instr_t;
+typedef uint32_t	dtrace_aggid_t;
+typedef uint32_t	dtrace_cacheid_t;
+typedef uint32_t	dtrace_epid_t;
+typedef uint32_t	uint_t;
+typedef uint32_t	processorid_t;
+
+typedef uint64_t	dtrace_genid_t;
+typedef uint64_t	dtrace_optval_t;
+
+typedef enum {
+	TRUE = -1,
+	FALSE = 0
+} boolean_t;
+
+typedef struct cred	cred_t;
+typedef struct hrtimer	hrtime_t;
+
+typedef typeof(((struct pt_regs *)0)->ip)	pc_t;
+
+#define P2ROUNDUP(x, a)	(-(-(x) & -(a)))
+
+typedef struct dtrace_ppriv {
+	uint32_t dtpp_flags;
+	uid_t dtpp_uid;
+	zoneid_t dtpp_zoneid;
+} dtrace_ppriv_t;
+
+typedef struct dtrace_attribute {
+	dtrace_stability_t dtat_name;
+	dtrace_stability_t dtat_data;
+	dtrace_class_t dtat_class;
+} dtrace_attribute_t;
+
+typedef struct dtrace_pattr {
+	dtrace_attribute_t dtpa_provider;
+	dtrace_attribute_t dtpa_mod;
+	dtrace_attribute_t dtpa_func;
+	dtrace_attribute_t dtpa_name;
+	dtrace_attribute_t dtpa_args;
+} dtrace_pattr_t;
+
+typedef uint32_t dtrace_id_t;
+
+typedef struct dtrace_probedesc {
+	dtrace_id_t dtpd_id;
+	char dtpd_provider[DTRACE_PROVNAMELEN];
+	char dtpd_mod[DTRACE_MODNAMELEN];
+	char dtpd_func[DTRACE_FUNCNAMELEN];
+	char dtpd_name[DTRACE_NAMELEN];
+} dtrace_probedesc_t;
+
+typedef struct dtrace_argdesc {
+	dtrace_id_t dtargd_id;
+	int dtargd_ndx;
+	int dtargd_mapping;
+	char dtargd_native[DTRACE_ARGTYPELEN];
+	char dtargd_xlate[DTRACE_ARGTYPELEN];
+} dtrace_argdesc_t;
+
+typedef struct dtrace_pops {
+	void (*dtps_provide)(void *, const dtrace_probedesc_t *);
+	void (*dtps_provide_module)(void *, struct module *);
+	int (*dtps_enable)(void *, dtrace_id_t, void *);
+	void (*dtps_disable)(void *, dtrace_id_t, void *);
+	void (*dtps_suspend)(void *, dtrace_id_t, void *);
+	void (*dtps_resume)(void *, dtrace_id_t, void *);
+	void (*dtps_getargdesc)(void *, dtrace_id_t, void *,
+				dtrace_argdesc_t *);
+	uint64_t (*dtps_getargval)(void *, dtrace_id_t, void *, int, int);
+	int (*dtps_usermode)(void *, dtrace_id_t, void *);
+	void (*dtps_destroy)(void *, dtrace_id_t, void *);
+} dtrace_pops_t;
+
+typedef struct dtrace_helper_probedesc {
+	char *dthpb_mod;
+	char *dthpb_func;
+	char *dthpb_name;
+	uint64_t dthpb_base;
+	uint32_t *dthpb_offs;
+	uint32_t *dthpb_enoffs;
+	uint32_t dthpb_noffs;
+	uint32_t dthpb_nenoffs;
+	uint8_t *dthpb_args;
+	uint8_t dthpb_xargc;
+	uint8_t dthpb_nargc;
+	char *dthpb_xtypes;
+	char *dthpb_ntypes;
+} dtrace_helper_probedesc_t;
+
+typedef struct dtrace_helper_provdesc {
+	char *dthpv_provname;
+	dtrace_pattr_t dthpv_pattr;
+} dtrace_helper_provdesc_t;
+
+typedef struct dtrace_mops {
+	void (*dtms_create_probe)(void *, void *, dtrace_helper_probedesc_t *);
+	void (*dtms_provide_pid)(void *, dtrace_helper_provdesc_t *, pid_t);
+	void (*dtms_remove_pid)(void *, dtrace_helper_provdesc_t *, pid_t);
+} dtrace_mops_t;
+
+typedef struct dtrace_provider {
+	dtrace_pattr_t dtpv_attr;
+	dtrace_ppriv_t dtpv_priv;
+	dtrace_pops_t dtpv_pops;
+	char *dtpv_name;
+	void *dtpv_arg;
+	uint_t dtpv_defunct;
+	struct dtrace_provider *dtpv_next;
+} dtrace_provider_t;
+
+typedef struct dtrace_diftype {
+	uint8_t dtdt_kind;
+	uint8_t dtdt_ckind;
+	uint8_t dtdt_flags;
+	uint8_t dtdt_pad;
+	uint32_t dtdt_size;
+} dtrace_diftype_t;
+
+typedef struct dtrace_difv {
+	uint32_t dtdv_name;
+	uint32_t dtdv_id;
+	uint8_t dtdv_kind;
+	uint8_t dtdv_scope;
+	uint16_t dtdv_flags;
+	dtrace_diftype_t dtdv_type;
+} dtrace_difv_t;
+
+typedef struct dtrace_difo {
+	dif_instr_t *dtdo_buf;
+	uint64_t *dtdo_inttab;
+	char *dtdo_strtab;
+	dtrace_difv_t *dtdo_vartab;
+	uint_t dtdo_len;
+	uint_t dtdo_intlen;
+	uint_t dtdo_strlen;
+	uint_t dtdo_varlen;
+	dtrace_diftype_t dtdo_rtype;
+	uint_t dtdo_refcnt;
+	uint_t dtdo_destructive;
+#ifndef __KERNEL__
+	dof_relodesc_t *dtdo_kreltab;
+	dof_relodesc_t *dtdo_ureltab;
+	struct dt_node **dtdo_xlmtab;
+	uint_t dtdo_krelen;
+	uint_t dtdo_urelen;
+	uint_t dtdo_xlmlen;
+#endif
+} dtrace_difo_t;
+
+typedef struct dtrace_actdesc {
+	dtrace_difo_t *dtad_difo;
+	struct dtrace_actdesc *dtad_next;
+	dtrace_actkind_t dtad_kind;
+	uint32_t dtad_ntuple;
+	uint64_t dtad_arg;
+	uint64_t dtad_uarg;
+	int dtad_refcnt;
+} dtrace_actdesc_t;
+
+typedef struct dtrace_predicate {
+	dtrace_difo_t *dtp_difo;
+	dtrace_cacheid_t dtp_cacheid;
+	int dtp_refcnt;
+} dtrace_predicate_t;
+
+typedef struct dtrace_preddesc {
+	dtrace_difo_t *dtpdd_difo;
+	dtrace_predicate_t *dtpdd_predicate;
+} dtrace_preddesc_t;
+
+typedef struct dtrace_ecbdesc {
+	dtrace_actdesc_t *dted_action;
+	dtrace_preddesc_t dted_pred;
+	dtrace_probedesc_t dted_probe;
+	uint64_t dted_uarg;
+	int dted_refcnt;
+} dtrace_ecbdesc_t;
+
+typedef struct dtrace_statvar {
+	uint64_t dtsv_data;
+	size_t dtsv_size;
+	int dtsv_refcnt;
+	dtrace_difv_t dtsv_var;
+} dtrace_statvar_t;
+
+typedef struct dtrace_recdesc {
+	dtrace_actkind_t dtrd_action;
+	uint32_t dtrd_size;
+	uint32_t dtrd_offset;
+	uint16_t dtrd_alignment;
+	uint16_t dtrd_format;
+	uint64_t dtrd_arg;
+	uint64_t dtrd_uarg;
+} dtrace_recdesc_t;
+
+typedef struct dtrace_action {
+	dtrace_actkind_t dta_kind;
+	uint16_t dta_intuple;
+	uint32_t dta_refcnt;
+	dtrace_difo_t *dta_difo;
+	dtrace_recdesc_t dta_rec;
+	struct dtrace_action *dta_prev;
+	struct dtrace_action *dta_next;
+} dtrace_action_t;
+
+struct dtrace_ecb;
+typedef struct dtrace_ecb	dtrace_ecb_t;
+
+typedef struct dtrace_probe {
+	dtrace_id_t dtpr_id;
+	dtrace_ecb_t *dtpr_ecb;
+	dtrace_ecb_t *dtpr_ecb_last;
+	void *dtpr_arg;
+	dtrace_cacheid_t dtpr_predcache;
+	int dtpr_aframes;
+	dtrace_provider_t *dtpr_provider;
+	char *dtpr_mod;
+	char *dtpr_func;
+	char *dtpr_name;
+	struct dtrace_probe *dtpr_nextmod;
+	struct dtrace_probe *dtpr_prevmod;
+	struct dtrace_probe *dtpr_nextfunc;
+	struct dtrace_probe *dtpr_prevfunc;
+	struct dtrace_probe *dtpr_nextname;
+	struct dtrace_probe *dtpr_prevname;
+	dtrace_genid_t dtpr_gen;
+} dtrace_probe_t;
+
+struct dtrace_state;
+typedef struct dtrace_state	dtrace_state_t;
+
+struct dtrace_ecb {
+	dtrace_epid_t dte_epid;
+	uint32_t dte_alignment;
+	size_t dte_needed;
+	size_t dte_size;
+	dtrace_predicate_t *dte_predicate;
+	dtrace_action_t *dte_action;
+	struct dtrace_ecb *dte_next;
+	dtrace_state_t *dte_state;
+	uint32_t dte_cond;
+	dtrace_probe_t *dte_probe;
+	dtrace_action_t *dte_action_last;
+	uint64_t dte_uarg;
+};
+
+typedef enum dtrace_activity {
+	DTRACE_ACTIVITY_INACTIVE = 0,
+	DTRACE_ACTIVITY_WARMUP,
+	DTRACE_ACTIVITY_ACTIVE,
+	DTRACE_ACTIVITY_DRAINING,
+	DTRACE_ACTIVITY_COOLDOWN,
+	DTRACE_ACTIVITY_STOPPED,
+	DTRACE_ACTIVITY_KILLED
+} dtrace_activity_t;
+
+typedef enum dtrace_dstate_state {
+	DTRACE_DSTATE_CLEAN = 0,
+	DTRACE_DSTATE_EMPTY,
+	DTRACE_DSTATE_DIRTY,
+	DTRACE_DSTATE_RINSING
+} dtrace_dstate_state_t;
+
+typedef struct dtrace_key {
+	uint64_t dttk_value;
+	uint64_t dttk_size;
+} dtrace_key_t;
+
+typedef struct dtrace_tuple {
+	uint32_t dtt_nkeys;
+	uint32_t dtt_pad;
+	dtrace_key_t dtt_key[1];
+} dtrace_tuple_t;
+
+typedef struct dtrace_dynvar {
+	uint64_t dtdv_hashval;
+	struct dtrace_dynvar *dtdv_next;
+	void *dtdv_data;
+	dtrace_tuple_t dtdv_tuple;
+} dtrace_dynvar_t;
+
+typedef struct dtrace_dstate_percpu {
+	dtrace_dynvar_t *dtdsc_free;
+	dtrace_dynvar_t *dtdsc_dirty;
+	dtrace_dynvar_t *dtdsc_rinsing;
+	dtrace_dynvar_t *dtdsc_clean;
+	uint64_t dtdsc_drops;
+	uint64_t dtdsc_dirty_drops;
+	uint64_t dtdsc_rinsing_drops;
+#ifdef _LP64
+	uint64_t dtdsc_pad;
+#else
+	uint64_t dtdsc_pad[2];
+#endif
+} dtrace_dstate_percpu_t;
+
+typedef struct dtrace_dynhash {
+	dtrace_dynvar_t *dtdh_chain;
+	uintptr_t dtdh_lock;
+#ifdef _LP64
+	uintptr_t dtdh_pad[6];
+#else
+	uintptr_t dtdh_pad[14];
+#endif
+} dtrace_dynhash_t;
+
+typedef struct dtrace_dstate {
+	void *dtds_base;
+	size_t dtds_size;
+	size_t dtds_hashsize;
+	size_t dtds_chunksize;
+	dtrace_dynhash_t *dtds_hash;
+	dtrace_dstate_state_t dtds_state;
+	dtrace_dstate_percpu_t *dtds_percpu;
+} dtrace_dstate_t;
+
+typedef struct dtrace_vstate {
+	dtrace_state_t *dtvs_state;
+	dtrace_statvar_t **dtvs_globals;
+	int dtvs_nglobals;
+	dtrace_difv_t *dtvs_tlocals;
+	int dtvs_ntlocals;
+	dtrace_statvar_t **dtvs_locals;
+	int dtvs_nlocals;
+	dtrace_dstate_t dtvs_dynvars;
+} dtrace_vstate_t;
+
+typedef struct dtrace_buffer {
+	uint64_t dtb_offset;
+	uint64_t dtb_size;
+	uint32_t dtb_flags;
+	uint32_t dtb_drops;
+	caddr_t dtb_tomax;
+	caddr_t dtb_xamot;
+	uint32_t dtb_xamot_flags;
+	uint32_t dtb_xamot_drops;
+	uint64_t dtb_xamot_offset;
+	uint32_t dtb_errors;
+	uint32_t dtb_xamot_errors;
+#ifndef _LP64
+	uint64_t dtb_pad1;
+#endif
+} dtrace_buffer_t;
+
+typedef enum dtrace_speculation_state {
+	DTRACESPEC_INACTIVE = 0,
+	DTRACESPEC_ACTIVE,
+	DTRACESPEC_ACTIVEONE,
+	DTRACESPEC_ACTIVEMANY,
+	DTRACESPEC_COMMITTING,
+	DTRACESPEC_COMMITTINGMANY,
+	DTRACESPEC_DISCARDING
+} dtrace_speculation_state_t;
+
+typedef struct dtrace_speculation {
+	dtrace_speculation_state_t dtsp_state;
+	int dtsp_cleaning;
+	dtrace_buffer_t *dtsp_buffer;
+} dtrace_speculation_t;
+
+typedef struct dtrace_aggregation {
+	dtrace_action_t dtag_action;
+	dtrace_aggid_t dtag_id;
+	dtrace_ecb_t *dtag_ecb;
+	dtrace_action_t *dtag_first;
+	uint32_t dtag_base;
+	uint8_t dtag_hasarg;
+	uint64_t dtag_initial;
+	void (*dtag_aggregate)(uint64_t *, uint64_t, uint64_t);
+} dtrace_aggregation_t;
+
+typedef struct dtrace_cred {
+	const cred_t *dcr_cred;
+	uint8_t dcr_destructive;
+	uint8_t dcr_visible;
+	uint16_t dcr_action;
+} dtrace_cred_t;
+
+struct dtrace_state {
+	dev_t dts_dev;
+	int dts_necbs;
+	dtrace_ecb_t **dts_ecbs;
+	dtrace_epid_t dts_epid;
+	size_t dts_needed;
+	struct dtrace_state *dts_anon;
+	dtrace_activity_t dts_activity;
+	dtrace_vstate_t dts_vstate;
+	dtrace_buffer_t *dts_buffer;
+	dtrace_buffer_t *dts_aggbuffer;
+	dtrace_speculation_t *dts_speculations;
+	int dts_nspeculations;
+	int dts_naggregations;
+	dtrace_aggregation_t **dts_aggregations;
+	void *dts_aggid_arena;	/* NOT USED / FIXME: was vmem_t * */
+	uint64_t dts_errors;
+	uint32_t dts_speculations_busy;
+	uint32_t dts_speculations_unavail;
+	uint32_t dts_stkstroverflows;
+	uint32_t dts_dblerrors;
+	uint32_t dts_reserve;
+	hrtime_t dts_laststatus;
+	cyclic_id_t dts_cleaner;
+	cyclic_id_t dts_deadman;
+	hrtime_t dts_alive;
+	char dts_speculates;
+	char dts_destructive;
+	int dts_nformats;
+	char **dts_formats;
+	dtrace_optval_t dts_options[DTRACEOPT_MAX];
+	dtrace_cred_t dts_cred;
+	size_t dts_nretained;
+};
+
+typedef struct dtrace_enabling {
+	dtrace_ecbdesc_t **dten_desc;
+	int dten_ndesc;
+	int dten_maxdesc;
+	dtrace_vstate_t *dten_vstate;
+	dtrace_genid_t dten_probegen;
+	dtrace_ecbdesc_t *dten_current;
+	int dten_error;
+	int dten_primed;
+	struct dtrace_enabling *dten_prev;
+	struct dtrace_enabling *dten_next;
+} dtrace_enabling_t;
+
+typedef int dtrace_probekey_f(const char *, const char *, int);
+
+typedef struct dtrace_probekey {
+	const char *dtpk_prov;
+	dtrace_probekey_f *dtpk_pmatch;
+	const char *dtpk_mod;
+	dtrace_probekey_f *dtpk_mmatch;
+	const char *dtpk_func;
+	dtrace_probekey_f *dtpk_fmatch;
+	const char *dtpk_name;
+	dtrace_probekey_f *dtpk_nmatch;
+	dtrace_id_t dtpk_id;
+} dtrace_probekey_t;
+
+typedef struct dtrace_hashbucket {
+	struct dtrace_hashbucket *dthb_next;
+	dtrace_probe_t *dthb_chain;
+	int dthb_len;
+} dtrace_hashbucket_t;
+
+typedef struct dtrace_hash {
+	dtrace_hashbucket_t **dth_tab;
+	int dth_size;
+	int dth_mask;
+	int dth_nbuckets;
+	uintptr_t dth_nextoffs;
+	uintptr_t dth_prevoffs;
+	uintptr_t dth_stroffs;
+} dtrace_hash_t;
+
+/*
+ * DTrace supports safe loads from probe context; if the address turns out to
+ * be invalid, a bit will be set by the kernel indicating that DTrace
+ * encountered a memory error, and DTrace will propagate the error to the user
+ * accordingly.  However, there may exist some regions of memory in which an
+ * arbitrary load can change system state, and from which it is impossible to
+ * recover from such a load after it has been attempted.  Examples of this may
+ * include memory in which programmable I/O registers are mapped (for which a
+ * read may have some implications for the device) or (in the specific case of
+ * UltraSPARC-I and -II) the virtual address hole.  The platform is required
+ * to make DTrace aware of these toxic ranges; DTrace will then check that
+ * target addresses are not in a toxic range before attempting to issue a
+ * safe load.
+ */
+typedef struct dtrace_toxrange {
+	uintptr_t dtt_base;
+	uintptr_t dtt_limit;
+} dtrace_toxrange_t;
+
+extern struct mutex		dtrace_lock;
+extern struct mutex		dtrace_provider_lock;
+extern struct mutex		dtrace_meta_lock;
+
+extern dtrace_genid_t		dtrace_probegen;
+
+extern dtrace_pops_t		dtrace_provider_ops;
+
+extern int			dtrace_opens;
+
+extern void dtrace_nullop(void);
+extern int dtrace_enable_nullop(void);
+
+/*
+ * DTrace Probe Context Functions
+ */
+#undef ASSERT
+#ifdef DEBUG
+# define ASSERT(x)	((void)((x) || dtrace_assfail(#x, __FILE__, __LINE__)))
+#else
+# define ASSERT(x)	((void)0)
+#endif
+
+extern int dtrace_assfail(const char *, const char *, int);
+extern void dtrace_aggregate_min(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_max(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_quantize(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_lquantize(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_avg(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_stddev(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_count(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_sum(uint64_t *, uint64_t, uint64_t);
+
+/*
+ * DTrace Probe Hashing Functions
+ */
+#define DTRACE_HASHNEXT(hash, probe)	\
+	(dtrace_probe_t **)((uintptr_t)(probe) + (hash)->dth_nextoffs)
+#define DTRACE_HASHPREV(hash, probe)	\
+	(dtrace_probe_t **)((uintptr_t)(probe) + (hash)->dth_prevoffs)
+
+extern dtrace_hash_t *dtrace_hash_create(uintptr_t, uintptr_t, uintptr_t);
+extern void dtrace_hash_add(dtrace_hash_t *, dtrace_probe_t *);
+extern dtrace_probe_t *dtrace_hash_lookup(dtrace_hash_t *, dtrace_probe_t *);
+extern int dtrace_hash_collisions(dtrace_hash_t *, dtrace_probe_t *);
+extern void dtrace_hash_remove(dtrace_hash_t *, dtrace_probe_t *);
+
+/*
+ * DTrace Non-Probe Context Utility Functions
+ */
+
+/*
+ * DTrace Matching Function
+ */
+extern dtrace_hash_t		*dtrace_bymod;
+extern dtrace_hash_t		*dtrace_byfunc;
+extern dtrace_hash_t		*dtrace_byname;
+
+extern int dtrace_match_priv(const dtrace_probe_t *, uint32_t, uid_t);
+extern int dtrace_match_probe(const dtrace_probe_t *,
+			      const dtrace_probekey_t *, uint32_t, uid_t);
+extern int dtrace_match(const dtrace_probekey_t *, uint32_t, uid_t,
+			int (*matched)(dtrace_probe_t *, void *), void *arg);
+extern void dtrace_probekey(const dtrace_probedesc_t *, dtrace_probekey_t *);
+
+/*
+ * DTrace Provider-to-Framework API Functions
+ */
+typedef uintptr_t		dtrace_provider_id_t;
+typedef uintptr_t		dtrace_meta_provider_id_t;
+
+extern dtrace_provider_t	*dtrace_provider;
+
+extern int dtrace_register(const char *, const dtrace_pattr_t *, uint32_t,
+			   cred_t *, const dtrace_pops_t *, void *,
+			   dtrace_provider_id_t *);
+extern int dtrace_unregister(dtrace_provider_id_t);
+
+extern int dtrace_meta_register(const char *, const dtrace_mops_t *, void *,
+				dtrace_meta_provider_id_t *);
+extern int dtrace_meta_unregister(dtrace_meta_provider_id_t);
+
+/*
+ * DTrace Probe Management Functions
+ */
+extern struct idr		dtrace_probe_idr;
+
+extern dtrace_id_t dtrace_probe_create(dtrace_provider_id_t, const char *,
+				       const char *, const char *, int,
+				       void *);
+extern int dtrace_probe_enable(const dtrace_probedesc_t *,
+			       dtrace_enabling_t *);
+extern void dtrace_probe_provide(dtrace_probedesc_t *, dtrace_provider_t *);
+extern dtrace_probe_t *dtrace_probe_lookup_id(dtrace_id_t);
+
+/*
+ * DTrace DIF Object Functions
+ */
+extern void dtrace_difo_hold(dtrace_difo_t *);
+extern void dtrace_difo_release(dtrace_difo_t *, dtrace_vstate_t *);
+
+/*
+ * DTrace Format Functions
+ */
+extern uint16_t dtrace_format_add(dtrace_state_t *, char *);
+extern void dtrace_format_remove(dtrace_state_t *, uint16_t);
+extern void dtrace_format_destroy(dtrace_state_t *);
+
+/*
+ * DTrace Predicate Functions
+ */
+extern void dtrace_predicate_hold(dtrace_predicate_t *);
+extern void dtrace_predicate_release(dtrace_predicate_t *, dtrace_vstate_t *);
+
+/*
+ * DTrace Action Description Functions
+ */
+extern dtrace_actdesc_t *dtrace_actdesc_create(dtrace_actkind_t, uint32_t,
+					       uint64_t, uint64_t);
+extern void dtrace_actdesc_hold(dtrace_actdesc_t *);
+extern void dtrace_actdesc_release(dtrace_actdesc_t *, dtrace_vstate_t *);
+
+/*
+ * DTrace ECB Functions
+ */
+extern dtrace_ecb_t		*dtrace_ecb_create_cache;
+
+extern int dtrace_ecb_create_enable(dtrace_probe_t *, void *);
+extern void dtrace_ecb_disable(dtrace_ecb_t *);
+extern void dtrace_ecb_destroy(dtrace_ecb_t *);
+extern void dtrace_ecb_resize(dtrace_ecb_t *);
+extern int dtrace_ecb_enable(dtrace_ecb_t *);
+
+/*
+ * DTrace Buffer Functions
+ */
+extern void dtrace_buffer_free(dtrace_buffer_t *);
+
+/*
+ * DTrace Enabling Functions
+ */
+extern dtrace_enabling_t	*dtrace_retained;
+extern dtrace_genid_t		dtrace_retained_gen;
+
+extern void dtrace_enabling_destroy(dtrace_enabling_t *);
+extern void dtrace_enabling_retract(dtrace_state_t *);
+extern void dtrace_enabling_matchall(void);
+extern void dtrace_enabling_provide(dtrace_provider_t *);
+
+/*
+ * DTrace BOF Functions
+ */
+
+/*
+ * DTrace Anonymous Enabling Functions
+ */
+typedef struct dtrace_anon {
+	dtrace_state_t *dta_state;
+	dtrace_enabling_t *dta_enabling;
+	processorid_t dta_beganon;
+} dtrace_anon_t;
+
+extern dtrace_anon_t		dtrace_anon;
+
+/*
+ * DTrace Consumer State Functions
+ */
+extern struct kmem_cache	*dtrace_state_cache;
+
+extern void dtrace_dstate_fini(dtrace_dstate_t *);
+extern void dtrace_vstate_fini(dtrace_vstate_t *);
+extern dtrace_state_t *dtrace_state_create(struct file *);
+extern void dtrace_state_destroy(dtrace_state_t *);
+
+/*
+ * DTrace Utility Functions
+ */
+extern int dtrace_badattr(const dtrace_attribute_t *);
+extern int dtrace_badname(const char *);
+extern void dtrace_cred2priv(const cred_t *, uint32_t *, uid_t *);
+
+#define DT_PROVIDER_MODULE(name)					\
+  static dtrace_provider_id_t name##_id;				\
+									\
+  static int __init name##_init(void)					\
+  {									\
+	int ret = 0;							\
+									\
+	ret = name##_dev_init();					\
+	if (ret)							\
+		goto failed;						\
+									\
+	ret = dtrace_register(__stringify(name), &name##_attr,		\
+			      DTRACE_PRIV_USER, NULL, &name##_pops,	\
+			      NULL, &name##_id);			\
+	if (ret)							\
+		goto failed;						\
+									\
+	return 0;							\
+									\
+  failed:								\
+	return ret;							\
+  }									\
+									\
+  static void __exit name##_exit(void)					\
+  {									\
+	dtrace_unregister(name##_id);					\
+	name##_dev_exit();						\
+  }									\
+									\
+  module_init(name##_init);						\
+  module_exit(name##_exit);
+
+#define dtrace_membar_producer()	mb()
+#define dtrace_membar_consumer()	mb()
+
+extern void dtrace_sync(void);
+extern void dtrace_toxic_ranges(void (*)(uintptr_t, uintptr_t));
+extern void dtrace_vpanic(const char *, va_list);
+
+extern void dtrace_vtime_enable(void);
+extern void dtrace_vtime_disable(void);
+
+
+#endif /* _DTRACE_H_ */
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_hash.c ./kernel/dtrace/dtrace_hash.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_hash.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_hash.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,203 @@
+/*
+ * FILE:	dtrace_hash.c
+ * DESCRIPTION:	Dynamic Tracing: probe hashing functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+#define DTRACE_HASHSTR(hash, probe)	\
+	dtrace_hash_str(*((char **)((uintptr_t)(probe) + (hash)->dth_stroffs)))
+#define DTRACE_HASHEQ(hash, lhs, rhs)	\
+	(strcmp(*((char **)((uintptr_t)(lhs) + (hash)->dth_stroffs)), \
+		*((char **)((uintptr_t)(rhs) + (hash)->dth_stroffs))) == 0)
+
+static uint_t dtrace_hash_str(char *p)
+{
+	uint_t	g;
+	uint_t	hval = 0;
+
+	while (*p) {
+		hval = (hval << 4) + *p++;
+		if ((g = (hval & 0xf0000000)) != 0)
+			hval ^= g >> 24;
+
+		hval &= ~g;
+	}
+
+	return hval;
+}
+
+dtrace_hash_t *dtrace_hash_create(uintptr_t stroffs, uintptr_t nextoffs,
+				  uintptr_t prevoffs)
+{
+	dtrace_hash_t	*hash = kzalloc(sizeof (dtrace_hash_t), GFP_KERNEL);
+
+	hash->dth_stroffs = stroffs;
+	hash->dth_nextoffs = nextoffs;
+	hash->dth_prevoffs = prevoffs;
+
+	hash->dth_size = 1;
+	hash->dth_mask = hash->dth_size - 1;
+
+	hash->dth_tab = kzalloc(hash->dth_size *
+				sizeof (dtrace_hashbucket_t *), GFP_KERNEL);
+
+	return hash;
+}
+
+static void dtrace_hash_resize(dtrace_hash_t *hash)
+{
+	int			size = hash->dth_size, i, ndx;
+	int			new_size = hash->dth_size << 1;
+	int			new_mask = new_size - 1;
+	dtrace_hashbucket_t	**new_tab, *bucket, *next;
+
+	ASSERT((new_size & new_mask) == 0);
+
+	new_tab = kzalloc(new_size * sizeof (void *), GFP_KERNEL);
+
+	for (i = 0; i < size; i++) {
+		for (bucket = hash->dth_tab[i]; bucket != NULL;
+		     bucket = next) {
+			dtrace_probe_t *probe = bucket->dthb_chain;
+
+			ASSERT(probe != NULL);
+			ndx = DTRACE_HASHSTR(hash, probe) & new_mask;
+
+			next = bucket->dthb_next;
+			bucket->dthb_next = new_tab[ndx];
+			new_tab[ndx] = bucket;
+		}
+	}
+
+	kfree(hash->dth_tab);
+	hash->dth_tab = new_tab;
+	hash->dth_size = new_size;
+	hash->dth_mask = new_mask;
+}
+
+void dtrace_hash_add(dtrace_hash_t *hash, dtrace_probe_t *new)
+{
+	int			hashval = DTRACE_HASHSTR(hash, new);
+	int			ndx = hashval & hash->dth_mask;
+	dtrace_hashbucket_t	*bucket = hash->dth_tab[ndx];
+	dtrace_probe_t		**nextp, **prevp;
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, new))
+			goto add;
+	}
+
+	if ((hash->dth_nbuckets >> 1) > hash->dth_size) {
+		dtrace_hash_resize(hash);
+		dtrace_hash_add(hash, new);
+		return;
+	}
+
+	bucket = kzalloc(sizeof (dtrace_hashbucket_t), GFP_KERNEL);
+	bucket->dthb_next = hash->dth_tab[ndx];
+	hash->dth_tab[ndx] = bucket;
+	hash->dth_nbuckets++;
+
+add:
+	nextp = DTRACE_HASHNEXT(hash, new);
+
+	ASSERT(*nextp == NULL && *(DTRACE_HASHPREV(hash, new)) == NULL);
+
+	*nextp = bucket->dthb_chain;
+
+	if (bucket->dthb_chain != NULL) {
+		prevp = DTRACE_HASHPREV(hash, bucket->dthb_chain);
+
+		ASSERT(*prevp == NULL);
+
+		*prevp = new;
+	}
+
+	bucket->dthb_chain = new;
+	bucket->dthb_len++;
+}
+
+dtrace_probe_t *dtrace_hash_lookup(dtrace_hash_t *hash,
+				   dtrace_probe_t *template)
+{
+	int			hashval = DTRACE_HASHSTR(hash, template);
+	int			ndx = hashval & hash->dth_mask;
+	dtrace_hashbucket_t	*bucket = hash->dth_tab[ndx];
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, template))
+			return bucket->dthb_chain;
+	}
+
+	return NULL;
+}
+
+int dtrace_hash_collisions(dtrace_hash_t *hash, dtrace_probe_t *template)
+{
+	int			hashval = DTRACE_HASHSTR(hash, template);
+	int			ndx = hashval & hash->dth_mask;
+	dtrace_hashbucket_t	*bucket = hash->dth_tab[ndx];
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, template))
+			return bucket->dthb_len;
+	}
+
+	return 0;
+}
+
+void dtrace_hash_remove(dtrace_hash_t *hash, dtrace_probe_t *probe)
+{
+	int			ndx = DTRACE_HASHSTR(hash, probe) &
+				      hash->dth_mask;
+	dtrace_hashbucket_t	*bucket = hash->dth_tab[ndx];
+	dtrace_probe_t		**prevp = DTRACE_HASHPREV(hash, probe);
+	dtrace_probe_t		**nextp = DTRACE_HASHNEXT(hash, probe);
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, probe))
+			break;
+	}
+
+	ASSERT(bucket != NULL);
+
+	if (*prevp == NULL) {
+		if (*nextp == NULL) {
+			/*
+			 * This is the last probe in the bucket; we can remove
+			 * the bucket.
+			 */
+			dtrace_hashbucket_t	*b = hash->dth_tab[ndx];
+
+			ASSERT(bucket->dthb_chain == probe);
+			ASSERT(b != NULL);
+
+			if (b == bucket)
+				hash->dth_tab[ndx] = bucket->dthb_next;
+			else {
+				while (b->dthb_next != bucket)
+					b = b->dthb_next;
+
+				b->dthb_next = bucket->dthb_next;
+			}
+
+			ASSERT(hash->dth_nbuckets > 0);
+
+			hash->dth_nbuckets--;
+			kfree(bucket);
+
+			return;
+		}
+
+		bucket->dthb_chain = *nextp;
+	} else
+		*(DTRACE_HASHNEXT(hash, *prevp)) = *nextp;
+
+	if (*nextp != NULL)
+		*(DTRACE_HASHPREV(hash, *nextp)) = *prevp;
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_match.c ./kernel/dtrace/dtrace_match.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_match.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_match.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,327 @@
+/*
+ * FILE:	dtrace_match.c
+ * DESCRIPTION:	Dynamic Tracing: matching functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/idr.h>
+
+#include "dtrace.h"
+
+dtrace_hash_t	*dtrace_bymod;
+dtrace_hash_t	*dtrace_byfunc;
+dtrace_hash_t	*dtrace_byname;
+
+int dtrace_match_priv(const dtrace_probe_t *prp, uint32_t priv, uid_t uid)
+{
+	if (priv != DTRACE_PRIV_ALL) {
+		uint32_t	ppriv =
+				prp->dtpr_provider->dtpv_priv.dtpp_flags;
+		uint32_t	match = priv & ppriv;
+
+		if ((priv & (DTRACE_PRIV_PROC | DTRACE_PRIV_USER |
+		    DTRACE_PRIV_KERNEL)) == 0)
+			return 0;
+
+		if (match == 0 && ppriv != 0)
+			return 0;
+
+		if (((ppriv & ~match) & DTRACE_PRIV_OWNER) != 0 &&
+		    uid != prp->dtpr_provider->dtpv_priv.dtpp_uid)
+			return 0;
+	}
+
+	return 1;
+}
+
+int dtrace_match_probe(const dtrace_probe_t *prp, const dtrace_probekey_t *pkp,
+		       uint32_t priv, uid_t uid)
+{
+	dtrace_provider_t	*pvp = prp->dtpr_provider;
+	int			rv;
+
+	if (pvp->dtpv_defunct)
+		return 0;
+
+	if ((rv = pkp->dtpk_pmatch(pvp->dtpv_name, pkp->dtpk_prov, 0)) <= 0)
+		return rv;
+
+	if ((rv = pkp->dtpk_mmatch(prp->dtpr_mod, pkp->dtpk_mod, 0)) <= 0)
+		return rv;
+
+	if ((rv = pkp->dtpk_fmatch(prp->dtpr_func, pkp->dtpk_func, 0)) <= 0)
+		return rv;
+
+	if ((rv = pkp->dtpk_nmatch(prp->dtpr_name, pkp->dtpk_name, 0)) <= 0)
+		return rv;
+
+	if (dtrace_match_priv(prp, priv, uid) == 0)
+		return 0;
+
+        return rv;
+}
+
+static int dtrace_match_glob(const char *s, const char *p, int depth)
+{
+	const char	*olds;
+	char		s1, c;
+	int		gs;
+
+	if (depth > DTRACE_PROBEKEY_MAXDEPTH)
+		return -1;
+
+	if (s == NULL)
+		s = "";
+
+top:
+	olds = s;
+	s1 = *s++;
+
+	if (p == NULL)
+		return 0;
+
+	if ((c = *p++) == '\0')
+		return s1 == '\0';
+
+	switch (c) {
+	case '[':
+		{
+			int	ok = 0, notflag = 0;
+			char	lc = '\0';
+
+			if (s1 == '\0')
+				return 0;
+
+			if (*p == '!') {
+				notflag = 1;
+				p++;
+			}
+
+			if ((c = *p++) == '\0')
+				return 0;
+
+			do {
+				if (c == '-' && lc != '\0' && *p != ']') {
+					if ((c = *p++) == '\0')
+						return 0;
+					if (c == '\\' && (c = *p++) == '\0')
+						return 0;
+
+					if (notflag) {
+						if (s1 < lc || s1 > c)
+							ok++;
+						else
+							return 0;
+					} else if (lc <= s1 && s1 <= c)
+						ok++;
+				} else if (c == '\\' && (c = *p++) == '\0')
+					return 0;
+
+				lc = c;
+
+				if (notflag) {
+					if (s1 != c)
+						ok++;
+					else
+						return 0;
+				} else if (s1 == c)
+					ok++;
+
+				if ((c = *p++) == '\0')
+					return 0;
+			} while (c != ']');
+
+			if (ok)
+				goto top;
+
+			return 0;
+		}
+
+	case '\\':
+		if ((c = *p++) == '\0')
+			return 0;
+
+	default:
+		if (c != s1)
+			return 0;
+
+	case '?':
+		if (s1 != '\0')
+			goto top;
+
+		return 0;
+
+	case '*':
+		while (*p == '*')
+			p++;
+
+		if (*p == '\0')
+			return 1;
+
+		for (s = olds; *s != '\0'; s++) {
+			if ((gs = dtrace_match_glob(s, p, depth + 1)) != 0)
+				return gs;
+		}
+
+		return 0;
+	}
+}
+
+static int dtrace_match_string(const char *s, const char *p, int depth)
+{
+	return s != NULL && strcmp(s, p) == 0;
+}
+
+static int dtrace_match_nul(const char *s, const char *p, int depth)
+{
+	return 1;
+}
+
+static int dtrace_match_nonzero(const char *s, const char *p, int depth)
+{
+	return s != NULL && s[0] != '\0';
+}
+
+struct probe_match {
+	const dtrace_probekey_t *pkp;
+	uint32_t		priv;
+	uid_t			uid;
+	int			(*matched)(dtrace_probe_t *, void *);
+	void			*arg;
+	int			nmatched;
+};
+
+static int dtrace_match_one(int id, void *p, void *data)
+{
+	struct probe_match	*pbm	= (struct probe_match *)data;
+	dtrace_probe_t		*probe	= (dtrace_probe_t *)p;
+	int			rc;
+
+	if (dtrace_match_probe(probe, pbm->pkp, pbm->priv, pbm->uid) <= 0)
+		return 0;
+
+	pbm->nmatched++;
+
+	if ((rc = (pbm->matched)(probe, pbm->arg)) != DTRACE_MATCH_NEXT) {
+		if (rc == DTRACE_MATCH_FAIL)
+			return DTRACE_MATCH_FAIL;
+	}
+
+	return 0;
+}
+
+int dtrace_match(const dtrace_probekey_t *pkp, uint32_t priv, uid_t uid,
+		 int (*matched)(dtrace_probe_t *, void *), void *arg)
+{
+	dtrace_probe_t	template, *probe;
+	dtrace_hash_t	*hash = NULL;
+	int		len, rc, best = INT_MAX, nmatched = 0;
+
+	if (pkp->dtpk_id != DTRACE_IDNONE) {
+		if ((probe = dtrace_probe_lookup_id(pkp->dtpk_id)) != NULL &&
+		    dtrace_match_probe(probe, pkp, priv, uid) > 0) {
+			if ((*matched)(probe, arg) == DTRACE_MATCH_FAIL)
+				return DTRACE_MATCH_FAIL;
+
+			nmatched++;
+		}
+
+		return nmatched;
+	}
+
+	template.dtpr_mod = (char *)pkp->dtpk_mod;
+	template.dtpr_func = (char *)pkp->dtpk_func;
+	template.dtpr_name = (char *)pkp->dtpk_name;
+
+	if (pkp->dtpk_mmatch == &dtrace_match_string &&
+	    (len = dtrace_hash_collisions(dtrace_bymod, &template)) < best) {
+		best = len;
+		hash = dtrace_bymod;
+	}
+
+	if (pkp->dtpk_fmatch == &dtrace_match_string &&
+	    (len = dtrace_hash_collisions(dtrace_byfunc, &template)) < best) {
+		best = len;
+		hash = dtrace_byfunc;
+	}
+
+	if (pkp->dtpk_nmatch == &dtrace_match_string &&
+	    (len = dtrace_hash_collisions(dtrace_byname, &template)) < best) {
+		best = len;
+		hash = dtrace_byname;
+	}
+
+	if (hash == NULL) {
+		struct probe_match	pbm;
+
+		pbm.pkp = pkp;
+		pbm.priv = priv;
+		pbm.uid = uid;
+		pbm.matched = matched;
+		pbm.arg = arg;
+		pbm.nmatched = 0;
+
+		rc = idr_for_each(&dtrace_probe_idr, dtrace_match_one, &pbm);
+		if (rc == DTRACE_MATCH_FAIL)
+			return DTRACE_MATCH_FAIL;
+
+		return pbm.nmatched;
+	}
+
+	for (probe = dtrace_hash_lookup(hash, &template); probe != NULL;
+	     probe = *(DTRACE_HASHNEXT(hash, probe))) {
+		if (dtrace_match_probe(probe, pkp, priv, uid) <= 0)
+			continue;
+
+		nmatched++;
+
+		if ((rc = (*matched)(probe, arg)) != DTRACE_MATCH_NEXT) {
+			if (rc == DTRACE_MATCH_FAIL)
+				return DTRACE_MATCH_FAIL;
+
+			break;
+		}
+	}
+
+	return nmatched;
+}
+
+static dtrace_probekey_f *dtrace_probekey_func(const char *p)
+{
+	char	c;
+
+	if (p == NULL || *p == '\0')
+		return &dtrace_match_nul;
+
+	while ((c = *p++) != '\0') {
+		if (c == '[' || c == '?' || c == '*' || c == '\\')
+			return &dtrace_match_glob;
+	}
+
+	return &dtrace_match_string;
+}
+
+void dtrace_probekey(const dtrace_probedesc_t *pdp, dtrace_probekey_t *pkp)
+{
+	pkp->dtpk_prov = pdp->dtpd_provider;
+	pkp->dtpk_pmatch = dtrace_probekey_func(pdp->dtpd_provider);
+
+	pkp->dtpk_mod = pdp->dtpd_mod;
+	pkp->dtpk_mmatch = dtrace_probekey_func(pdp->dtpd_mod);
+
+	pkp->dtpk_func = pdp->dtpd_func;
+	pkp->dtpk_fmatch = dtrace_probekey_func(pdp->dtpd_func);
+
+	pkp->dtpk_name = pdp->dtpd_name;
+	pkp->dtpk_nmatch = dtrace_probekey_func(pdp->dtpd_name);
+
+	pkp->dtpk_id = pdp->dtpd_id;
+
+	if (pkp->dtpk_id == DTRACE_IDNONE &&
+	    pkp->dtpk_pmatch == &dtrace_match_nul &&
+	    pkp->dtpk_mmatch == &dtrace_match_nul &&
+	    pkp->dtpk_fmatch == &dtrace_match_nul &&
+	    pkp->dtpk_nmatch == &dtrace_match_nul)
+		pkp->dtpk_fmatch = &dtrace_match_nonzero;
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_mod.c ./kernel/dtrace/dtrace_mod.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_mod.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_mod.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,34 @@
+/*
+ * FILE:	dtrace_mod.c
+ * DESCRIPTION:	Dynamic Tracing: module handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/module.h>
+
+#include "dtrace_dev.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Dynamic Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("Proprietary");
+
+/*
+ * Initialize the module.
+ */
+static int __init dtrace_init(void)
+{
+	return dtrace_dev_init();
+}
+
+/*
+ * Perform cleanup before the module is removed.
+ */
+static void __exit dtrace_exit(void)
+{
+	dtrace_dev_exit();
+}
+
+module_init(dtrace_init);
+module_exit(dtrace_exit);
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_predicate.c ./kernel/dtrace/dtrace_predicate.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_predicate.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_predicate.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,34 @@
+/*
+ * FILE:	dtrace_predicate.c
+ * DESCRIPTION:	Dynamic Tracing: predicate functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+void dtrace_predicate_hold(dtrace_predicate_t *pred)
+{
+	ASSERT(mutex_is_locked(&dtrace_lock));
+	ASSERT(pred->dtp_difo != NULL && pred->dtp_difo->dtdo_refcnt != 0);
+	ASSERT(pred->dtp_refcnt > 0);
+
+	pred->dtp_refcnt++;
+}
+
+void dtrace_predicate_release(dtrace_predicate_t *pred,
+			      dtrace_vstate_t *vstate)
+{
+	dtrace_difo_t *dp = pred->dtp_difo;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+	ASSERT(dp != NULL && dp->dtdo_refcnt != 0);
+	ASSERT(pred->dtp_refcnt > 0);
+
+	if (--pred->dtp_refcnt == 0) {
+		dtrace_difo_release(dp, vstate);
+		kfree(pred);
+	}
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_probe.c ./kernel/dtrace/dtrace_probe.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_probe.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_probe.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,125 @@
+/*
+ * FILE:	dtrace_probe.c
+ * DESCRIPTION:	Dynamic Tracing: probe management functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/idr.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+struct idr	dtrace_probe_idr;
+
+/*
+ * Create a new probe.
+ */
+dtrace_id_t dtrace_probe_create(dtrace_provider_id_t prov, const char *mod,
+				const char *func, const char *name,
+				int aframes, void *arg)
+{
+	dtrace_probe_t		*probe;
+	dtrace_provider_t	*provider = (dtrace_provider_t *)prov;
+	dtrace_id_t		id;
+	int			err;
+
+	probe = kzalloc(sizeof (dtrace_probe_t), __GFP_NOFAIL);
+
+	/*
+	 * The idr_pre_get() function should be called without holding locks.
+	 * When the provider is the DTrace core itself, dtrace_lock will be
+	 * held when we enter this function.
+	 */
+	if (provider == dtrace_provider) {
+		ASSERT(mutex_is_locked(&dtrace_lock));
+		mutex_unlock(&dtrace_lock);
+	}
+
+again:
+	idr_pre_get(&dtrace_probe_idr, __GFP_NOFAIL);
+
+	mutex_lock(&dtrace_lock);
+	err = idr_get_new(&dtrace_probe_idr, probe, &id);
+	if (err == -EAGAIN) {
+		mutex_unlock(&dtrace_lock);
+		goto again;
+	}
+
+	probe->dtpr_id = id;
+	probe->dtpr_gen = dtrace_probegen++;
+	probe->dtpr_mod = kstrdup(mod, GFP_KERNEL);
+	probe->dtpr_func = kstrdup(func, GFP_KERNEL);
+	probe->dtpr_name = kstrdup(name, GFP_KERNEL);
+	probe->dtpr_arg = arg;
+	probe->dtpr_aframes = aframes;
+	probe->dtpr_provider = provider;
+
+	dtrace_hash_add(dtrace_bymod, probe);
+	dtrace_hash_add(dtrace_byfunc, probe);
+	dtrace_hash_add(dtrace_byname, probe);
+
+	if (provider != dtrace_provider)
+		mutex_unlock(&dtrace_lock);
+
+	return id;
+}
+
+int dtrace_probe_enable(const dtrace_probedesc_t *desc, dtrace_enabling_t *enab)
+{
+	dtrace_probekey_t	pkey;
+	uint32_t		priv;
+	uid_t			uid;
+
+	dtrace_ecb_create_cache = NULL;
+
+	if (desc == NULL) {
+		(void) dtrace_ecb_create_enable(NULL, enab);
+
+		return 0;
+	}
+
+	dtrace_probekey(desc, &pkey);
+	dtrace_cred2priv(enab->dten_vstate->dtvs_state->dts_cred.dcr_cred,
+			 &priv, &uid);
+
+	return dtrace_match(&pkey, priv, uid, dtrace_ecb_create_enable, enab);
+}
+
+void dtrace_probe_provide(dtrace_probedesc_t *desc, dtrace_provider_t *prv)
+{
+	struct module	*mod;
+	int		all = 0;
+
+	if (prv == NULL) {
+		all = 1;
+		prv = dtrace_provider;
+	}
+
+	do {
+		prv->dtpv_pops.dtps_provide(prv->dtpv_arg, desc);
+
+#ifdef FIXME
+/*
+ * This needs work because (so far) I have not found a way to get access to the
+ * list of modules in Linux.
+ */
+		mutex_lock(&module_mutex);
+
+		list_for_each_entry(mod, &modules, list) {
+			if (mod->state != MODULE_STATE_LIVE)
+				continue;
+
+			prv->dtpv_pops.dtps_provide_module(prv->dtpv_arg, mod);
+		}
+
+		mutex_unlock(&module_mutex);
+#endif
+	} while (all && (prv = prv->dtpv_next) != NULL);
+}
+
+dtrace_probe_t *dtrace_probe_lookup_id(dtrace_id_t id)
+{
+	return idr_find(&dtrace_probe_idr, id);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_probe_ctx.c ./kernel/dtrace/dtrace_probe_ctx.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_probe_ctx.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_probe_ctx.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,206 @@
+/*
+ * FILE:	dtrace_probe_ctx.c
+ * DESCRIPTION:	Dynamic Tracing: probe context functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include "dtrace.h"
+
+static void dtrace_panic(const char *fmt, ...)
+{
+	va_list		alist;
+
+	va_start(alist, fmt);
+	vprintk(fmt, alist);
+	va_end(alist);
+
+	BUG();
+}
+
+int dtrace_assfail(const char *a, const char *f, int l)
+{
+	dtrace_panic("assertion failed: %s, file: %s, line: %d", a, f, l);
+
+	/*
+	 * FIXME: We can do better than this.  The OpenSolaris DTrace source
+	 * states that this cannot be optimized away.
+	 */
+	return a[(uintptr_t)f];
+}
+EXPORT_SYMBOL(dtrace_assfail);
+
+#define DT_MASK_LO	0x00000000FFFFFFFFULL
+
+static void dtrace_add_128(uint64_t *addend1, uint64_t *addend2, uint64_t *sum)
+{
+	uint64_t	result[2];
+
+	result[0] = addend1[0] + addend2[0];
+	result[1] = addend1[1] + addend2[1] +
+		    (result[0] < addend1[0] || result[0] < addend2[0] ? 1 : 0);
+
+	sum[0] = result[0];
+	sum[1] = result[1];
+}
+
+static void dtrace_shift_128(uint64_t *a, int b)
+{
+	uint64_t	mask;
+
+	if (b == 0)
+		return;
+
+	if (b < 0) {
+		b = -b;
+
+		if (b >= 64) {
+			a[0] = a[1] >> (b - 64);
+			a[1] = 0;
+		} else {
+			a[0] >>= b;
+			mask = 1LL << (64 - b);
+			mask -= 1;
+			a[0] |= ((a[1] & mask) << (64 - b));
+			a[1] >>= b;
+		}
+	} else {
+		if (b >= 64) {
+			a[1] = a[0] << (b - 64);
+			a[0] = 0;
+		} else {
+			a[1] <<= b;
+			mask = a[0] >> (64 - b);
+			a[1] |= mask;
+			a[0] <<= b;
+		}
+	}
+}
+
+static void dtrace_multiply_128(uint64_t factor1, uint64_t factor2,
+				uint64_t *product)
+{
+	uint64_t	hi1, hi2, lo1, lo2;
+	uint64_t	tmp[2];
+
+	hi1 = factor1 >> 32;
+	hi2 = factor2 >> 32;
+
+	lo1 = factor1 & DT_MASK_LO;
+	lo2 = factor2 & DT_MASK_LO;
+
+	product[0] = lo1 * lo2;
+	product[1] = hi1 * hi2;
+
+	tmp[0] = hi1 * lo2;
+	tmp[1] = 0;
+	dtrace_shift_128(tmp, 32);
+	dtrace_add_128(product, tmp, product);
+
+	tmp[0] = hi2 * lo1;
+	tmp[1] = 0;
+	dtrace_shift_128(tmp, 32);
+	dtrace_add_128(product, tmp, product);
+}
+
+void dtrace_aggregate_min(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	if ((int64_t)nval < (int64_t)*oval)
+		*oval = nval;
+}
+
+void dtrace_aggregate_max(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	if ((int64_t)nval > (int64_t)*oval)
+		*oval = nval;
+}
+
+void dtrace_aggregate_quantize(uint64_t *quanta, uint64_t nval, uint64_t incr)
+{
+	int	i, zero = DTRACE_QUANTIZE_ZEROBUCKET;
+	int64_t	val = (int64_t)nval;
+
+	if (val < 0) {
+		for (i = 0; i < zero; i++) {
+			if (val <= DTRACE_QUANTIZE_BUCKETVAL(i)) {
+				quanta[i] += incr;
+
+				return;
+			}
+		}
+	} else {
+		for (i = zero + 1; i < DTRACE_QUANTIZE_NBUCKETS; i++) {
+			if (val < DTRACE_QUANTIZE_BUCKETVAL(i)) {
+				quanta[i - 1] += incr;
+
+				return;
+			}
+		}
+
+		quanta[DTRACE_QUANTIZE_NBUCKETS - 1] += incr;
+
+		return;
+	}
+
+	ASSERT(0);
+}
+
+void dtrace_aggregate_lquantize(uint64_t *lquanta, uint64_t nval,
+				uint64_t incr)
+{
+	uint64_t	arg = *lquanta++;
+	int32_t		base = DTRACE_LQUANTIZE_BASE(arg);
+	uint16_t	step = DTRACE_LQUANTIZE_STEP(arg);
+	uint16_t	levels = DTRACE_LQUANTIZE_LEVELS(arg);
+	int32_t		val = (int32_t)nval, level;
+
+	ASSERT(step != 0);
+	ASSERT(levels != 0);
+
+	if (val < base) {
+		lquanta[0] += incr;
+
+		return;
+	}
+
+	level = (val - base) / step;
+
+	if (level < levels) {
+		lquanta[level + 1] += incr;
+
+		return;
+	}
+
+	lquanta[levels + 1] += incr;
+}
+
+void dtrace_aggregate_avg(uint64_t *data, uint64_t nval, uint64_t arg)
+{
+	data[0]++;
+	data[1] += nval;
+}
+
+void dtrace_aggregate_stddev(uint64_t *data, uint64_t nval, uint64_t arg)
+{
+	int64_t		snval = (int64_t)nval;
+	uint64_t	tmp[2];
+
+	data[0]++;
+	data[1] += nval;
+
+	if (snval < 0)
+		snval = -snval;
+
+	dtrace_multiply_128((uint64_t)snval, (uint64_t)snval, tmp);
+	dtrace_add_128(data + 2, tmp, data + 2);
+}
+
+void dtrace_aggregate_count(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	*oval = *oval + 1;
+}
+
+void dtrace_aggregate_sum(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	*oval += nval;
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_ptofapi.c ./kernel/dtrace/dtrace_ptofapi.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_ptofapi.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_ptofapi.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,335 @@
+/*
+ * FILE:	dtrace_ptofapi.c
+ * DESCRIPTION:	Dynamic Tracing: provider-to-framework API
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/idr.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+dtrace_provider_t	*dtrace_provider;
+
+DEFINE_MUTEX(dtrace_lock);
+DEFINE_MUTEX(dtrace_provider_lock);
+DEFINE_MUTEX(dtrace_meta_lock);
+
+/*
+ * Register the calling provider with the DTrace core.  This should generally
+ * be called by providers during module initialization.
+ */
+int dtrace_register(const char *name, const dtrace_pattr_t *pap, uint32_t priv,
+		    cred_t *cr, const dtrace_pops_t *pops, void *arg,
+		    dtrace_provider_id_t *idp)
+{
+	dtrace_provider_t	*provider;
+
+	if (name == NULL || pap == NULL || pops == NULL || idp == NULL) {
+		pr_warning("Failed to register provider %s: invalid args\n",
+			   name ? name : "<NULL>");
+		return -EINVAL;
+	}
+
+	if (name[0] == '\0' || dtrace_badname(name)) {
+		pr_warning("Failed to register provider %s: invalid name\n",
+			   name);
+		return -EINVAL;
+	}
+
+	if ((pops->dtps_provide == NULL && pops->dtps_provide_module == NULL) ||
+	    pops->dtps_enable == NULL || pops->dtps_disable == NULL ||
+	    pops->dtps_destroy == NULL ||
+	    ((pops->dtps_resume == NULL) != (pops->dtps_suspend == NULL))) {
+		pr_warning("Failed to register provider %s: invalid ops\n",
+			   name);
+		return -EINVAL;
+	}
+
+	if (dtrace_badattr(&pap->dtpa_provider) ||
+	    dtrace_badattr(&pap->dtpa_mod) ||
+	    dtrace_badattr(&pap->dtpa_func) ||
+	    dtrace_badattr(&pap->dtpa_name) ||
+	    dtrace_badattr(&pap->dtpa_args)) {
+		pr_warning("Failed to register provider %s: invalid "
+			   "attributes\n", name);
+		return -EINVAL;
+	}
+
+	if (priv & ~DTRACE_PRIV_ALL) {
+		pr_warning("Failed to register provider %s: invalid privilege "
+			   "attributes\n", name);
+		return -EINVAL;
+	}
+
+	if ((priv & DTRACE_PRIV_KERNEL) &&
+	    (priv & (DTRACE_PRIV_USER | DTRACE_PRIV_OWNER)) &&
+	    pops->dtps_usermode == NULL) {
+		pr_warning("Failed to register provider %s: need "
+			   "dtps_usermode() op for given privilege "
+			   "attributes\n", name);
+		return -EINVAL;
+	}
+
+	provider = kmalloc(sizeof (dtrace_provider_t), GFP_KERNEL);
+	provider->dtpv_name = kstrdup(name, GFP_KERNEL);
+	provider->dtpv_attr = *pap;
+	provider->dtpv_priv.dtpp_flags = priv;
+
+	if (cr != NULL) {
+		provider->dtpv_priv.dtpp_uid = get_cred(cr)->uid;
+		put_cred(cr);
+	}
+
+	provider->dtpv_pops = *pops;
+
+	if (pops->dtps_provide == NULL) {
+		ASSERT(pops->dtps_provide_module != NULL);
+		provider->dtpv_pops.dtps_provide =
+		    (void (*)(void *, const dtrace_probedesc_t *))dtrace_nullop;
+	}
+
+	if (pops->dtps_provide_module == NULL) {
+		ASSERT(pops->dtps_provide != NULL);
+		provider->dtpv_pops.dtps_provide_module =
+		    (void (*)(void *, struct module *))dtrace_nullop;
+	}
+
+	if (pops->dtps_suspend == NULL) {
+		ASSERT(pops->dtps_resume != NULL);
+		provider->dtpv_pops.dtps_suspend =
+		    (void (*)(void *, dtrace_id_t, void *))dtrace_nullop;
+		provider->dtpv_pops.dtps_resume =
+		    (void (*)(void *, dtrace_id_t, void *))dtrace_nullop;
+	}
+
+	provider->dtpv_arg = arg;
+	*idp = (dtrace_provider_id_t)provider;
+
+	if (pops == &dtrace_provider_ops) {
+		ASSERT(mutex_is_locked(&dtrace_provider_lock));
+		ASSERT(mutex_is_locked(&dtrace_lock));
+		ASSERT(dtrace_anon.dta_enabling == NULL);
+
+		/*
+		 * The DTrace provider must be at the head of the provider
+		 * chain.
+		 */
+		provider->dtpv_next = dtrace_provider;
+		dtrace_provider = provider;
+
+		return 0;
+	}
+
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * If there is at least one provider registered, we'll add this new one
+	 * after the first provider.
+	 */
+	if (dtrace_provider != NULL) {
+		provider->dtpv_next = dtrace_provider->dtpv_next;
+		dtrace_provider->dtpv_next = provider;
+	} else
+		dtrace_provider = provider;
+
+	if (dtrace_retained != NULL) {
+		dtrace_enabling_provide(provider);
+
+		/*
+		 * We must now call dtrace_enabling_matchall() which needs to
+		 * acquire FIXME(cpu_lock) and dtrace_lock.  We therefore need
+		 * to drop our locks before calling it.
+		 */
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_provider_lock);
+		dtrace_enabling_matchall();
+
+		return 0;
+	}
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_register);
+
+/*
+ * Check whether the given probe is still enabled for the given provider.
+ */
+static int dtrace_unregister_check(int id, void *p, void *data)
+{
+	dtrace_probe_t		*probe = (dtrace_probe_t *)p;
+	dtrace_provider_t	*prov = (dtrace_provider_t *)data;
+
+	if (probe->dtpr_provider != prov)
+		return 0;
+
+	if (probe->dtpr_ecb == NULL)
+		return 0;
+
+	return -EBUSY;
+}
+
+/*
+ * Remove the given probe from the hash tables and the probe IDR.  The probes
+ * are chained for further processing.
+ */
+static int dtrace_unregister_probe(int id, void *p, void *data)
+{
+	dtrace_probe_t	*probe = (dtrace_probe_t *)p;
+	dtrace_probe_t	**first = (dtrace_probe_t **)data;
+
+	dtrace_hash_remove(dtrace_bymod, probe);
+	dtrace_hash_remove(dtrace_byfunc, probe);
+	dtrace_hash_remove(dtrace_byname, probe);
+
+	if (*first == NULL) {
+		*first = probe;
+		probe->dtpr_nextmod = NULL;
+	} else {
+		probe->dtpr_nextmod = *first;
+		*first = probe;
+	}
+
+	return 0;
+}
+
+/*
+ * Unregister the specified provider from the DTrace core.  This should be
+ * called by provider during module cleanup.
+ */
+int dtrace_unregister(dtrace_provider_id_t id)
+{
+	dtrace_provider_t	*old = (dtrace_provider_t *)id;
+	dtrace_provider_t	*prev = NULL;
+	int			err, self = 0;
+	dtrace_probe_t		*probe, *first = NULL;
+
+	if (old->dtpv_pops.dtps_enable ==
+	    (int (*)(void *, dtrace_id_t, void *))dtrace_enable_nullop) {
+		/*
+		 * When the provider is the DTrace core itself, we're called
+		 * with locks already held.
+		 */
+		ASSERT(old == dtrace_provider);
+		ASSERT(mutex_is_locked(&dtrace_provider_lock));
+		ASSERT(mutex_is_locked(&dtrace_lock));
+
+		self = 1;
+
+		if (dtrace_provider->dtpv_next != NULL) {
+			/*
+			 * We cannot and should not remove the DTrace provider
+			 * if there is any other provider left.
+			 */
+			return -EBUSY;
+		}
+	} else {
+		mutex_lock(&dtrace_provider_lock);
+		/* FIXME: mutex_lock(&mod_lock); */
+		mutex_lock(&dtrace_lock);
+	}
+
+	/*
+	 * If /dev/dtrace/dtrace is still held open by a process, or if there
+	 * are anonymous probes that are still enabled, we refuse to deregister
+	 * providers, unless the provider has been invalidated explicitly.
+	 */
+	if (!old->dtpv_defunct &&
+	    (dtrace_opens || (dtrace_anon.dta_state != NULL &&
+	     dtrace_anon.dta_state->dts_necbs > 0))) {
+		if (!self) {
+			mutex_unlock(&dtrace_lock);
+			/* FIXME: mutex_unlock(&mod_lock); */
+			mutex_unlock(&dtrace_provider_lock);
+		}
+
+		return -EBUSY;
+	}
+
+	/*
+	 * Check whether any of the probes associated with this provider are
+	 * still enabled (having at least one ECB).  If any are found, we
+	 * cannot remove this provider.
+	 */
+	err = idr_for_each(&dtrace_probe_idr, dtrace_unregister_check, old);
+	if (err < 0) {
+		if (!self) {
+			mutex_unlock(&dtrace_lock);
+			/* FIXME: mutex_unlock(&mod_lock); */
+			mutex_unlock(&dtrace_provider_lock);
+		}
+
+		return err;
+	}
+
+	/*
+	 * All the probes associated with this provider are disabled.  We can
+	 * safely remove these probes from the hashtables and the probe array.
+	 * We chain all the probes together for further processing.
+	 */
+	idr_for_each(&dtrace_probe_idr, dtrace_unregister_probe, &first);
+
+	/*
+	 * The probes associated with the provider have been removed.  Ensure
+	 * synchronization on probe IDR processing.
+	 */
+	dtrace_sync();
+
+	/*
+	 * Now get rid of the actual probes.
+	 */
+	for (probe = first; probe != NULL; probe = first) {
+		int	probe_id = probe->dtpr_id;
+
+		first = probe->dtpr_nextmod;
+
+		old->dtpv_pops.dtps_destroy(old->dtpv_arg, probe_id,
+					    probe->dtpr_arg);
+
+		kfree(probe->dtpr_mod);
+		kfree(probe->dtpr_func);
+		kfree(probe->dtpr_name);
+		kfree(probe);
+
+		idr_remove(&dtrace_probe_idr, probe_id);
+	}
+
+	if ((prev = dtrace_provider) == old) {
+		/*
+		 * We are removing the provider at the head of the chain.
+		 */
+		ASSERT(self);
+		ASSERT(old->dtpv_next == NULL);
+
+		dtrace_provider = old->dtpv_next;
+	} else {
+		while (prev != NULL && prev->dtpv_next != old)
+			prev = prev->dtpv_next;
+
+		if (prev == NULL) {
+			pr_err("Attempt to unregister non-existent DTrace "
+			       "provider %p\n", (void *)id);
+			BUG();
+		}
+
+		prev->dtpv_next = old->dtpv_next;
+	}
+
+	if (!self) {
+		mutex_unlock(&dtrace_lock);
+		/* FIXME: mutex_unlock(&mod_lock); */
+		mutex_unlock(&dtrace_provider_lock);
+	}
+
+	kfree(old->dtpv_name);
+	kfree(old);
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_unregister);
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_state.c ./kernel/dtrace/dtrace_state.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_state.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_state.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,288 @@
+/*
+ * FILE:	dtrace_state.c
+ * DESCRIPTION:	Dynamic Tracing: consumer state functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/fs.h>
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+struct kmem_cache	*dtrace_state_cache;
+dtrace_optval_t		dtrace_nspec_default = 1;
+dtrace_optval_t		dtrace_specsize_default = 32 * 1024;
+size_t			dtrace_strsize_default = 256;
+dtrace_optval_t		dtrace_stackframes_default = 20;
+dtrace_optval_t		dtrace_ustackframes_default = 20;
+dtrace_optval_t		dtrace_cleanrate_default = 9900990;
+dtrace_optval_t		dtrace_aggrate_default = NANOSEC;
+dtrace_optval_t		dtrace_switchrate_default = NANOSEC;
+dtrace_optval_t		dtrace_statusrate_default = NANOSEC;
+dtrace_optval_t		dtrace_jstackframes_default = 50;
+dtrace_optval_t		dtrace_jstackstrsize_default = 512;
+
+void dtrace_dstate_fini(dtrace_dstate_t *dstate)
+{
+	/* FIXME: ASSERT(mutex_is_locked(&cpu_lock)); */
+
+	if (dstate->dtds_base == NULL)
+		return;
+
+	kfree(dstate->dtds_base);
+	kmem_cache_free(dtrace_state_cache, dstate->dtds_percpu); /* FIXME */
+}
+
+void dtrace_vstate_fini(dtrace_vstate_t *vstate)
+{
+	/*
+	 * If only there was a logical XOR operator...
+	 */
+	ASSERT((vstate->dtvs_nglobals == 0) ^ (vstate->dtvs_globals != NULL));
+
+	if (vstate->dtvs_nglobals > 0)
+		kfree(vstate->dtvs_globals);
+
+	if (vstate->dtvs_ntlocals > 0)
+		kfree(vstate->dtvs_tlocals);
+
+	ASSERT((vstate->dtvs_nlocals == 0) ^ (vstate->dtvs_locals != NULL));
+
+	if (vstate->dtvs_nlocals > 0)
+		kfree(vstate->dtvs_locals);
+}
+
+dtrace_state_t *dtrace_state_create(struct file *file)
+{
+	dtrace_state_t	*state;
+	dtrace_optval_t	*opt;
+	int		bufsize = NR_CPUS * sizeof (dtrace_buffer_t), i;
+	const cred_t	*cr = file->f_cred;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+	/* FIXME: ASSERT(mutex_is_locked(&cpu_lock)); */
+
+	state = kmalloc(sizeof (dtrace_state_t), GFP_KERNEL);
+	state->dts_epid = DTRACE_EPIDNONE + 1;
+	/* state->dts_dev = NULL;  -- FIXME: Do we even need this? */
+	state->dts_buffer = kzalloc(bufsize, GFP_KERNEL);
+	state->dts_aggbuffer = kzalloc(bufsize, GFP_KERNEL);
+	state->dts_cleaner = 0;
+	state->dts_deadman = 0;
+	state->dts_vstate.dtvs_state = state;
+
+	for (i = 0; i < DTRACEOPT_MAX; i++)
+		state->dts_options[i] = DTRACEOPT_UNSET;
+
+	/*
+	 * Set the default options.
+	 */
+	opt = state->dts_options;
+	opt[DTRACEOPT_BUFPOLICY] = DTRACEOPT_BUFPOLICY_SWITCH;
+	opt[DTRACEOPT_BUFRESIZE] = DTRACEOPT_BUFRESIZE_AUTO;
+	opt[DTRACEOPT_NSPEC] = dtrace_nspec_default;
+	opt[DTRACEOPT_SPECSIZE] = dtrace_specsize_default;
+	opt[DTRACEOPT_CPU] = (dtrace_optval_t)DTRACE_CPUALL;
+	opt[DTRACEOPT_STRSIZE] = dtrace_strsize_default;
+	opt[DTRACEOPT_STACKFRAMES] = dtrace_stackframes_default;
+	opt[DTRACEOPT_USTACKFRAMES] = dtrace_ustackframes_default;
+	opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_default;
+	opt[DTRACEOPT_AGGRATE] = dtrace_aggrate_default;
+	opt[DTRACEOPT_SWITCHRATE] = dtrace_switchrate_default;
+	opt[DTRACEOPT_STATUSRATE] = dtrace_statusrate_default;
+	opt[DTRACEOPT_JSTACKFRAMES] = dtrace_jstackframes_default;
+	opt[DTRACEOPT_JSTACKSTRSIZE] = dtrace_jstackstrsize_default;
+
+	state->dts_activity = DTRACE_ACTIVITY_INACTIVE;
+
+#ifdef FIXME
+	/*
+	 * Set probe visibility and destructiveness based on user credential
+	 * information.  For actual anonymous tracing or if all privileges are
+	 * set, checks are bypassed.
+	 */
+	if (cr == NULL ||
+	    PRIV_POLICY_ONLY(cr, PRIV_ALL, FALSE)) {
+		state->dts_cred.dcr_visible = DTRACE_CRV_ALL;
+		state->dts_cred.dcr_action = DTRACE_CRA_ALL;
+	} else {
+		state->dts_cred.dcr_cred = get_cred(cr);
+
+		/*
+		 * CRA_PROC means "we have *some* privilege for dtrace" and
+		 * it unlocks the use of variables like pid, etc.
+		 */
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_USER, FALSE) ||
+		    PRIV_POLICY_ONLY(cr, PRIV_DTRACE_PROC, FALSE))
+			state->dts_cred.dcr_action |= DTRACE_CRA_PROC;
+
+		/*
+		 * The DTRACE_USER privilege allows the use of syscall and
+		 * profile providers.  If the user also has PROC_OWNER, we
+		 * extend the scope to include additional visibility and
+		 * destructive power.
+		 */
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_USER, FALSE)) {
+			if (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, FALSE))
+				state->dts_cred.dcr_visible |=
+					DTRACE_CRV_ALLPROC;
+
+			state->dts_cred.dcr_action |=
+					DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;
+		}
+
+		/*
+		 * Holding the DTRACE_KERNEL privilege also implies that
+		 * the user has the DTRACE_USER privilege from a visibility
+		 * perspective.  But without further privileges, some
+		 * destructive actions are not available.
+		 */
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_KERNEL, FALSE)) {
+			/*
+			 * Make all probes in all zones visible.  However,
+			 * this doesn't mean that all actions become available
+			 * to all zones.
+			 */
+			state->dts_cred.dcr_visible |= DTRACE_CRV_KERNEL |
+						       DTRACE_CRV_ALLPROC;
+			state->dts_cred.dcr_action |= DTRACE_CRA_KERNEL |
+						      DTRACE_CRA_PROC;
+
+			/*
+			 * Holding PROC_OWNER means that destructive actions
+			 * are allowed.
+			 */
+			if (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, FALSE))
+				state->dts_cred.dcr_action |=
+					DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;
+		}
+
+		/*
+		 * Holding the DTRACE_PROC privilege gives control over the
+		 * fasttrap and pid providers.  We need to grant wider
+		 * destructive privileges in the event that the user has
+		 * PROC_OWNER .
+		*/
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_PROC, FALSE)) {
+			if (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, FALSE))
+				state->dts_cred.dcr_action |=
+					DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;
+		}
+	}
+#endif
+
+	return state;
+}
+
+void dtrace_state_destroy(dtrace_state_t *state)
+{
+	dtrace_ecb_t		*ecb;
+	dtrace_vstate_t		*vstate = &state->dts_vstate;
+	int			i;
+	dtrace_speculation_t	*spec = state->dts_speculations;
+	int			nspec = state->dts_nspeculations;
+	uint32_t		match;
+
+	ASSERT(mutex_is_locked(&dtrace_lock));
+	/* FIXME: ASSERT(mutex_is_locked(&cpu_lock)); */
+
+	/*
+	 * First, retract any retained enablings for this state.
+	 */
+	dtrace_enabling_retract(state);
+	ASSERT(state->dts_nretained == 0);
+
+	if (state->dts_activity == DTRACE_ACTIVITY_ACTIVE ||
+	    state->dts_activity == DTRACE_ACTIVITY_DRAINING) {
+		/*
+		 * We have managed to come into dtrace_state_destroy() on a
+		 * hot enabling -- almost certainly because of a disorderly
+		 * shutdown of a consumer.  (That is, a consumer that is
+		 * exiting without having called dtrace_stop().) In this case,
+		 * we're going to set our activity to be KILLED, and then
+		 * issue a sync to be sure that everyone is out of probe
+		 * context before we start blowing away ECBs.
+		 */
+		state->dts_activity = DTRACE_ACTIVITY_KILLED;
+		dtrace_sync();
+	}
+
+	/*
+	 * Release the credential hold we took in dtrace_state_create().
+	 */
+	if (state->dts_cred.dcr_cred != NULL)
+		put_cred(state->dts_cred.dcr_cred);
+
+	/*
+	 * Now we can safely disable and destroy any enabled probes.  Because
+	 * any DTRACE_PRIV_KERNEL probes may actually be slowing our progress
+	 * (especially if they're all enabled), we take two passes through the
+	 * ECBs: in the first, we disable just DTRACE_PRIV_KERNEL probes, and
+	 * in the second we disable whatever is left over.
+	*/
+	for (match = DTRACE_PRIV_KERNEL; ; match = 0) {
+		for (i = 0; i < state->dts_necbs; i++) {
+			if ((ecb = state->dts_ecbs[i]) == NULL)
+				continue;
+
+			if (match && ecb->dte_probe != NULL) {
+				dtrace_probe_t		*probe =
+							ecb->dte_probe;
+				dtrace_provider_t	*prov =
+							probe->dtpr_provider;
+
+				if (!(prov->dtpv_priv.dtpp_flags & match))
+					continue;
+			}
+
+			dtrace_ecb_disable(ecb);
+			dtrace_ecb_destroy(ecb);
+		}
+
+		if (!match)
+			break;
+	}
+
+	/*
+	 * Before we free the buffers, perform one more sync to assure that
+	 * every CPU is out of probe context.
+	 */
+	dtrace_sync();
+
+	dtrace_buffer_free(state->dts_buffer);
+	dtrace_buffer_free(state->dts_aggbuffer);
+
+	for (i = 0; i < nspec; i++)
+		dtrace_buffer_free(spec[i].dtsp_buffer);
+
+	if (state->dts_cleaner != CYCLIC_NONE)
+		cyclic_remove(state->dts_cleaner);
+
+	if (state->dts_deadman != CYCLIC_NONE)
+		cyclic_remove(state->dts_deadman);
+
+	dtrace_dstate_fini(&vstate->dtvs_dynvars);
+	dtrace_vstate_fini(vstate);
+	kfree(state->dts_ecbs);
+
+	if (state->dts_aggregations != NULL) {
+#ifdef DEBUG
+		for (i = 0; i < state->dts_naggregations; i++)
+			ASSERT(state->dts_aggregations[i] == NULL);
+#endif
+
+		ASSERT(state->dts_naggregations > 0);
+		kfree(state->dts_aggregations);
+	}
+
+	kfree(state->dts_buffer);
+	kfree(state->dts_aggbuffer);
+
+	for (i = 0; i < nspec; i++)
+		kfree(spec[i].dtsp_buffer);
+
+	kfree(spec);
+
+	dtrace_format_destroy(state);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/dtrace_util.c ./kernel/dtrace/dtrace_util.c
--- ../linux-2.6.34/kernel/dtrace/dtrace_util.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/dtrace_util.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,74 @@
+/*
+ * FILE:	dtrace_util.c
+ * DESCRIPTION:	DTrace utility functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include "dtrace.h"
+
+int dtrace_badattr(const dtrace_attribute_t *a)
+{
+	return a->dtat_name > DTRACE_STABILITY_MAX ||
+	       a->dtat_data > DTRACE_STABILITY_MAX ||
+	       a->dtat_class > DTRACE_CLASS_MAX;
+}
+
+#define DTRACE_ISALPHA(c)	(((c) >= 'a' && (c) <= 'z') || \
+				 ((c) >= 'A' && (c) <= 'Z'))
+int dtrace_badname(const char *s)
+{
+	char	c;
+
+	if (s == NULL || (c = *s++) == '\0')
+		return 0;
+
+	if (!DTRACE_ISALPHA(c) && c != '-' && c!= '_' && c != '.')
+		return 1;
+
+	while ((c = *s++) != '\0') {
+		if (!DTRACE_ISALPHA(c) && (c < '0' || c > '9') &&
+		    c != '-' && c!= '_' && c != '.' && c != '`')
+			return 1;
+	}
+
+	return 0;
+}
+
+void dtrace_cred2priv(const cred_t *cr, uint32_t *privp, uid_t *uidp)
+{
+#ifdef FIXME
+/*
+ * This should probably be rewritten based on capabilities in the cred_t struct.
+ */
+	uint32_t	priv;
+
+	if (cr == NULL)
+		priv = DTRACE_PRIV_ALL;
+	else {
+		const cred_t	*lcr = get_cred(cr);
+
+		if (PRIV_POLICY_ONLY(lcr, PRIV_ALL, FALSE))
+			priv = DTRACE_PRIV_ALL;
+		else {
+			*uidp = lcr->uid;
+			priv = 0;
+
+			if (PRIV_POLICY_ONLY(lcr, PRIV_DTRACE_KERNEL, FALSE))
+				priv |= DTRACE_PRIV_KERNEL | DTRACE_PRIV_USER;
+			else if (PRIV_POLICY_ONLY(lcr, PRIV_DTRACE_USER,
+						  FALSE))
+				priv |= DTRACE_PRIV_USER;
+
+			if (PRIV_POLICY_ONLY(lcr, PRIV_DTRACE_PROC, FALSE))
+				priv |= DTRACE_PRIV_PROC;
+			if (PRIV_POLICY_ONLY(lcr, PRIV_PROC_OWNER, FALSE))
+				priv |= DTRACE_PRIV_OWNER;
+		}
+
+		put_cred(cr);
+	}
+
+	*privp = priv;
+#endif
+}
diff -urN ../linux-2.6.34/kernel/dtrace/fasttrap_dev.c ./kernel/dtrace/fasttrap_dev.c
--- ../linux-2.6.34/kernel/dtrace/fasttrap_dev.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/fasttrap_dev.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ * FILE:	fasttrap_dev.c
+ * DESCRIPTION:	Fasttrap Tracing: device file handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+
+#include "dtrace_dev.h"
+
+static long fasttrap_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int fasttrap_open(struct inode *inode, struct file *file)
+{
+	return -EAGAIN;
+}
+
+static int fasttrap_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations fasttrap_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = fasttrap_ioctl,
+        .open   = fasttrap_open,
+        .release = fasttrap_close,
+};
+
+static struct miscdevice fasttrap_dev = {
+	.minor = DT_DEV_FASTTRAP_MINOR,
+	.name = "fasttrap",
+	.nodename = "dtrace/provider/fasttrap",
+	.fops = &fasttrap_fops,
+};
+
+int fasttrap_dev_init(void)
+{
+	int ret = 0;
+
+	ret = misc_register(&fasttrap_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       fasttrap_dev.name, fasttrap_dev.minor);
+
+	return ret;
+}
+
+void fasttrap_dev_exit(void)
+{
+	misc_deregister(&fasttrap_dev);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/fasttrap.h ./kernel/dtrace/fasttrap.h
--- ../linux-2.6.34/kernel/dtrace/fasttrap.h	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/fasttrap.h	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,7 @@
+#ifndef _FASTTRAP_H_
+#define _FASTTRAP_H_
+
+extern int fasttrap_dev_init(void);
+extern int fasttrap_dev_exit(void);
+
+#endif /* _FASTTRAP_H_ */
diff -urN ../linux-2.6.34/kernel/dtrace/fasttrap_mod.c ./kernel/dtrace/fasttrap_mod.c
--- ../linux-2.6.34/kernel/dtrace/fasttrap_mod.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/fasttrap_mod.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * FILE:	fasttrap_mod.c
+ * DESCRIPTION:	Fasttrap Tracing: module handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "fasttrap.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Fasttrap Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("Proprietary");
+
+static const dtrace_pattr_t fasttrap_attr = {
+};
+
+static dtrace_pops_t fasttrap_pops = {
+};
+
+DT_PROVIDER_MODULE(fasttrap)
diff -urN ../linux-2.6.34/kernel/dtrace/fbt_dev.c ./kernel/dtrace/fbt_dev.c
--- ../linux-2.6.34/kernel/dtrace/fbt_dev.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/fbt_dev.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ * FILE:	fbt_dev.c
+ * DESCRIPTION:	Function Boundary Tracing: device file handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+
+#include "dtrace_dev.h"
+
+static long fbt_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int fbt_open(struct inode *inode, struct file *file)
+{
+	return -EAGAIN;
+}
+
+static int fbt_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations fbt_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = fbt_ioctl,
+        .open   = fbt_open,
+        .release = fbt_close,
+};
+
+static struct miscdevice fbt_dev = {
+	.minor = DT_DEV_FBT_MINOR,
+	.name = "fbt",
+	.nodename = "dtrace/provider/fbt",
+	.fops = &fbt_fops,
+};
+
+int fbt_dev_init(void)
+{
+	int ret = 0;
+
+	ret = misc_register(&fbt_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       fbt_dev.name, fbt_dev.minor);
+
+	return ret;
+}
+
+void fbt_dev_exit(void)
+{
+	misc_deregister(&fbt_dev);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/fbt.h ./kernel/dtrace/fbt.h
--- ../linux-2.6.34/kernel/dtrace/fbt.h	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/fbt.h	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,7 @@
+#ifndef _FBT_H_
+#define _FBT_H_
+
+extern int fbt_dev_init(void);
+extern int fbt_dev_exit(void);
+
+#endif /* _FBT_H_ */
diff -urN ../linux-2.6.34/kernel/dtrace/fbt_mod.c ./kernel/dtrace/fbt_mod.c
--- ../linux-2.6.34/kernel/dtrace/fbt_mod.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/fbt_mod.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * FILE:	fbt_dmod.c
+ * DESCRIPTION:	Function Boundary Tracing: module handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "fbt.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Function Boundary Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("Proprietary");
+
+static const dtrace_pattr_t fbt_attr = {
+};
+
+static dtrace_pops_t fbt_pops = {
+};
+
+DT_PROVIDER_MODULE(fbt);
diff -urN ../linux-2.6.34/kernel/dtrace/Kconfig ./kernel/dtrace/Kconfig
--- ../linux-2.6.34/kernel/dtrace/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/Kconfig	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,49 @@
+#
+# DTrace Configuration
+#
+
+menuconfig DTRACE
+	tristate "DTrace (Dynamic Tracing) Support"
+	default m
+	help
+	  To be written.
+
+if DTRACE
+
+config DT_FASTTRAP
+	tristate "Fasttrap Tracing"
+	depends on DTRACE
+	help
+	  To be written.
+
+config DT_FBT
+	tristate "Function Boundary Tracing"
+	depends on DTRACE
+	help
+	  To be written.
+
+config DT_LOCKSTAT
+	tristate "Lock Statistics"
+	depends on DTRACE
+	help
+	  To be written.
+
+config DT_PROFILE
+	tristate "Profile Interrupt Tracing"
+	depends on DTRACE
+	help
+	  To be written.
+
+config DT_SDT
+	tristate "Statically Defined Tracing"
+	depends on DTRACE
+	help
+	  To be written.
+
+config DT_SYSTRACE
+	tristate "System Call Tracing"
+	depends on DTRACE
+	help
+	  To be written.
+
+endif   #DTRACE
diff -urN ../linux-2.6.34/kernel/dtrace/lockstat_dev.c ./kernel/dtrace/lockstat_dev.c
--- ../linux-2.6.34/kernel/dtrace/lockstat_dev.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/lockstat_dev.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ * FILE:	lockstat_dev.c
+ * DESCRIPTION:	Lock Statistics: device file handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+
+#include "dtrace_dev.h"
+
+static long lockstat_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int lockstat_open(struct inode *inode, struct file *file)
+{
+	return -EAGAIN;
+}
+
+static int lockstat_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations lockstat_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = lockstat_ioctl,
+        .open   = lockstat_open,
+        .release = lockstat_close,
+};
+
+static struct miscdevice lockstat_dev = {
+	.minor = DT_DEV_LOCKSTAT_MINOR,
+	.name = "dtrace",
+	.nodename = "dtrace/provider/lockstat",
+	.fops = &lockstat_fops,
+};
+
+int lockstat_dev_init(void)
+{
+	int ret = 0;
+
+	ret = misc_register(&lockstat_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       lockstat_dev.name, lockstat_dev.minor);
+
+	return ret;
+}
+
+void lockstat_dev_exit(void)
+{
+	misc_deregister(&lockstat_dev);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/lockstat.h ./kernel/dtrace/lockstat.h
--- ../linux-2.6.34/kernel/dtrace/lockstat.h	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/lockstat.h	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,7 @@
+#ifndef _LOCKSTAT_H_
+#define _LOCKSTAT_H_
+
+extern int lockstat_dev_init(void);
+extern int lockstat_dev_exit(void);
+
+#endif /* _LOCKSTAT_H_ */
diff -urN ../linux-2.6.34/kernel/dtrace/lockstat_mod.c ./kernel/dtrace/lockstat_mod.c
--- ../linux-2.6.34/kernel/dtrace/lockstat_mod.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/lockstat_mod.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * FILE:	lockstat_mod.c
+ * DESCRIPTION:	Lock Statistics: module handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "lockstat.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Lock Statistics");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("Proprietary");
+
+static const dtrace_pattr_t lockstat_attr = {
+};
+
+static dtrace_pops_t lockstat_pops = {
+};
+
+DT_PROVIDER_MODULE(lockstat)
diff -urN ../linux-2.6.34/kernel/dtrace/Makefile ./kernel/dtrace/Makefile
--- ../linux-2.6.34/kernel/dtrace/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/Makefile	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,28 @@
+#
+# Makefile for DTrace
+#
+
+obj-$(CONFIG_DTRACE)		+= dtrace.o
+obj-$(CONFIG_DT_FASTTRAP)	+= fasttrap.o
+obj-$(CONFIG_DT_FBT)		+= fbt.o
+obj-$(CONFIG_DT_LOCKSTAT)	+= lockstat.o
+obj-$(CONFIG_DT_PROFILE)	+= profile.o
+obj-$(CONFIG_DT_SDT)		+= sdt.o
+obj-$(CONFIG_DT_SYSTRACE)	+= systrace.o
+
+dtrace-y			:= dtrace_mod.o dtrace_dev.o \
+				   dtrace_actdesc.o dtrace_anon.o \
+				   dtrace_buffer.o dtrace_dif.o \
+				   dtrace_ecb.o dtrace_enable.o \
+				   dtrace_fmt.o dtrace_hash.o \
+				   dtrace_match.o dtrace_probe.o \
+				   dtrace_probe_ctx.o \
+				   dtrace_ptofapi.o dtrace_predicate.o \
+				   dtrace_state.o dtrace_util.o \
+				   cyclic.o
+fasttrap-y			:= fasttrap_mod.o fasttrap_dev.o
+fbt-y				:= fbt_mod.o fbt_dev.o
+lockstat-y			:= lockstat_mod.o lockstat_dev.o
+profile-y			:= profile_mod.o profile_dev.o
+sdt-y				:= sdt_mod.o sdt_dev.o
+systrace-y			:= systrace_mod.o systrace_dev.o
diff -urN ../linux-2.6.34/kernel/dtrace/profile_dev.c ./kernel/dtrace/profile_dev.c
--- ../linux-2.6.34/kernel/dtrace/profile_dev.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/profile_dev.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ * FILE:	profile_dev.c
+ * DESCRIPTION:	Profile Interrupt Tracing: device file handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+
+#include "dtrace_dev.h"
+
+static long profile_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int profile_open(struct inode *inode, struct file *file)
+{
+	return -EAGAIN;
+}
+
+static int profile_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations profile_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = profile_ioctl,
+        .open   = profile_open,
+        .release = profile_close,
+};
+
+static struct miscdevice profile_dev = {
+	.minor = DT_DEV_PROFILE_MINOR,
+	.name = "profile",
+	.nodename = "dtrace/provider/profile",
+	.fops = &profile_fops,
+};
+
+int profile_dev_init(void)
+{
+	int ret = 0;
+
+	ret = misc_register(&profile_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       profile_dev.name, profile_dev.minor);
+
+	return ret;
+}
+
+void profile_dev_exit(void)
+{
+	misc_deregister(&profile_dev);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/profile.h ./kernel/dtrace/profile.h
--- ../linux-2.6.34/kernel/dtrace/profile.h	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/profile.h	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,7 @@
+#ifndef _PROFILE_H_
+#define _PROFILE_H_
+
+extern int profile_dev_init(void);
+extern int profile_dev_exit(void);
+
+#endif /* _PROFILE_H_ */
diff -urN ../linux-2.6.34/kernel/dtrace/profile_mod.c ./kernel/dtrace/profile_mod.c
--- ../linux-2.6.34/kernel/dtrace/profile_mod.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/profile_mod.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * FILE:	profile_mod.c
+ * DESCRIPTION:	Profile Interrupt Tracing: module handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "profile.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Profile Interrupt Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("Proprietary");
+
+static const dtrace_pattr_t profile_attr = {
+};
+
+static dtrace_pops_t profile_pops = {
+};
+
+DT_PROVIDER_MODULE(profile)
diff -urN ../linux-2.6.34/kernel/dtrace/sdt_dev.c ./kernel/dtrace/sdt_dev.c
--- ../linux-2.6.34/kernel/dtrace/sdt_dev.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/sdt_dev.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ * FILE:	sdt_dev.c
+ * DESCRIPTION:	Statically Defined Tracing: device file handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+
+#include "dtrace_dev.h"
+
+static long sdt_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int sdt_open(struct inode *inode, struct file *file)
+{
+	return -EAGAIN;
+}
+
+static int sdt_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations sdt_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = sdt_ioctl,
+        .open   = sdt_open,
+        .release = sdt_close,
+};
+
+static struct miscdevice sdt_dev = {
+	.minor = DT_DEV_SDT_MINOR,
+	.name = "sdt",
+	.nodename = "dtrace/provider/sdt",
+	.fops = &sdt_fops,
+};
+
+int sdt_dev_init(void)
+{
+	int ret = 0;
+
+	ret = misc_register(&sdt_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       sdt_dev.name, sdt_dev.minor);
+
+	return ret;
+}
+
+void sdt_dev_exit(void)
+{
+	misc_deregister(&sdt_dev);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/sdt.h ./kernel/dtrace/sdt.h
--- ../linux-2.6.34/kernel/dtrace/sdt.h	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/sdt.h	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,7 @@
+#ifndef _SDT_H_
+#define _SDT_H_
+
+extern int sdt_dev_init(void);
+extern int sdt_dev_exit(void);
+
+#endif /* _SDT_H_ */
diff -urN ../linux-2.6.34/kernel/dtrace/sdt_mod.c ./kernel/dtrace/sdt_mod.c
--- ../linux-2.6.34/kernel/dtrace/sdt_mod.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/sdt_mod.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * FILE:	sdt_mod.c
+ * DESCRIPTION:	Statically Defined Tracing: module handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "sdt.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Statically Defined Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("Proprietary");
+
+static const dtrace_pattr_t sdt_attr = {
+};
+
+static dtrace_pops_t sdt_pops = {
+};
+
+DT_PROVIDER_MODULE(sdt)
diff -urN ../linux-2.6.34/kernel/dtrace/systrace_dev.c ./kernel/dtrace/systrace_dev.c
--- ../linux-2.6.34/kernel/dtrace/systrace_dev.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/systrace_dev.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ * FILE:	systrace_dev.c
+ * DESCRIPTION:	System Call Tracing: device file handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+
+#include "dtrace_dev.h"
+
+static long systrace_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int systrace_open(struct inode *inode, struct file *file)
+{
+	return -EAGAIN;
+}
+
+static int systrace_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations systrace_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = systrace_ioctl,
+        .open   = systrace_open,
+        .release = systrace_close,
+};
+
+static struct miscdevice systrace_dev = {
+	.minor = DT_DEV_SYSTRACE_MINOR,
+	.name = "systrace",
+	.nodename = "dtrace/provider/systrace",
+	.fops = &systrace_fops,
+};
+
+int systrace_dev_init(void)
+{
+	int ret = 0;
+
+	ret = misc_register(&systrace_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       systrace_dev.name, systrace_dev.minor);
+
+	return ret;
+}
+
+void systrace_dev_exit(void)
+{
+	misc_deregister(&systrace_dev);
+}
diff -urN ../linux-2.6.34/kernel/dtrace/systrace.h ./kernel/dtrace/systrace.h
--- ../linux-2.6.34/kernel/dtrace/systrace.h	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/systrace.h	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,7 @@
+#ifndef _SYSTRACE_H_
+#define _SYSTRACE_H_
+
+extern int systrace_dev_init(void);
+extern int systrace_dev_exit(void);
+
+#endif /* _SYSTRACE_H_ */
diff -urN ../linux-2.6.34/kernel/dtrace/systrace_mod.c ./kernel/dtrace/systrace_mod.c
--- ../linux-2.6.34/kernel/dtrace/systrace_mod.c	1969-12-31 19:00:00.000000000 -0500
+++ ./kernel/dtrace/systrace_mod.c	2010-09-30 14:08:58.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * FILE:	systrace_mod.c
+ * DESCRIPTION:	System Call Tracing: module handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "systrace.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("System Call Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("Proprietary");
+
+static const dtrace_pattr_t systrace_attr = {
+};
+
+static dtrace_pops_t systrace_pops = {
+};
+
+DT_PROVIDER_MODULE(systrace);
diff -urN ../linux-2.6.34/kernel/Makefile ./kernel/Makefile
--- ../linux-2.6.34/kernel/Makefile	2010-07-28 17:48:29.000000000 -0400
+++ ./kernel/Makefile	2010-08-19 00:33:59.000000000 -0400
@@ -105,6 +105,7 @@
 obj-$(CONFIG_HAVE_HW_BREAKPOINT) += hw_breakpoint.o
 obj-$(CONFIG_USER_RETURN_NOTIFIER) += user-return-notifier.o
 obj-$(CONFIG_PADATA) += padata.o
+obj-$(CONFIG_DTRACE) += dtrace/
 
 ifneq ($(CONFIG_SCHED_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
